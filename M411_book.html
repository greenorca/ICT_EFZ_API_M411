<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Modul 411</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="buttondown.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Modul 411</h1>
<p class="subtitle">Datenstrukturen und Algorithmen</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#willkommen-zurück-bei-in-java"><span class="toc-section-number">1</span> Willkommen (zurück) bei in Java</a><ul>
<li><a href="#wichtige-hinweise-für-lernende"><span class="toc-section-number">1.1</span> Wichtige Hinweise für Lernende</a></li>
<li><a href="#handlungsziele-nach-ict-vorgaben-bivo-2014"><span class="toc-section-number">1.2</span> Handlungsziele nach ICT-Vorgaben (BiVo 2014)</a></li>
<li><a href="#kursablauf"><span class="toc-section-number">1.3</span> Kursablauf</a></li>
<li><a href="#hinweis-für-verbesserungen"><span class="toc-section-number">1.4</span> Hinweis für Verbesserungen</a></li>
</ul></li>
<li><a href="#klassen-erstellen"><span class="toc-section-number">2</span> Klassen erstellen</a><ul>
<li><a href="#lernziele"><span class="toc-section-number">2.1</span> Lernziele</a></li>
<li><a href="#die-main-methode"><span class="toc-section-number">2.2</span> Die main-Methode</a></li>
<li><a href="#übung-java-ide-und-ein-ausgaben"><span class="toc-section-number">2.3</span> Übung: Java IDE und Ein-/Ausgaben</a></li>
</ul></li>
<li><a href="#ein--und-ausgabe-über-die-konsole"><span class="toc-section-number">3</span> Ein- und Ausgabe über die Konsole</a><ul>
<li><a href="#ausgabe"><span class="toc-section-number">3.1</span> Ausgabe</a></li>
<li><a href="#eingabe"><span class="toc-section-number">3.2</span> Eingabe</a></li>
<li><a href="#übung-numerische-ein-ausgaben"><span class="toc-section-number">3.3</span> Übung: Numerische Ein-/Ausgaben</a></li>
</ul></li>
<li><a href="#strukturiere-daten-lesen-und-schreiben"><span class="toc-section-number">4</span> Strukturiere Daten lesen und schreiben</a><ul>
<li><a href="#lernziele_file_io"><span class="toc-section-number">4.1</span> Lernziele</a></li>
<li><a href="#bufferedreader"><span class="toc-section-number">4.2</span> BufferedReader</a><ul>
<li><a href="#erstellen-eines-bufferedreader"><span class="toc-section-number">4.2.1</span> Erstellen eines BufferedReader</a></li>
<li><a href="#bufferedreader-oder-scanner"><span class="toc-section-number">4.2.2</span> BufferedReader oder Scanner?</a></li>
</ul></li>
<li><a href="#strukturierte-textfiles"><span class="toc-section-number">4.3</span> Strukturierte Textfiles</a><ul>
<li><a href="#nummerische-werte-behandeln"><span class="toc-section-number">4.3.1</span> Nummerische Werte behandeln</a></li>
</ul></li>
<li><a href="#übung-textdateien-einlesen"><span class="toc-section-number">4.4</span> Übung: Textdateien einlesen</a></li>
<li><a href="#daten-strukturiert-in-ein-file-schreiben"><span class="toc-section-number">4.5</span> Daten strukturiert in ein File schreiben</a></li>
<li><a href="#übung-csv-schreiben"><span class="toc-section-number">4.6</span> Übung: CSV schreiben</a></li>
<li><a href="#wdh_intro"><span class="toc-section-number">4.7</span> Wiederholungsfragen</a></li>
</ul></li>
<li><a href="#arrays"><span class="toc-section-number">5</span> Arrays</a><ul>
<li><a href="#lernziele_array"><span class="toc-section-number">5.1</span> Lernziele</a></li>
<li><a href="#was-haben-algorithmen-und-datenstrukturen-miteinander-zu-tun"><span class="toc-section-number">5.2</span> Was haben Algorithmen und Datenstrukturen miteinander zu tun?</a></li>
<li><a href="#die-elementare-datenstruktur-array"><span class="toc-section-number">5.3</span> Die elementare Datenstruktur: Array</a><ul>
<li><a href="#initialisierung-und-zugriff-via-index"><span class="toc-section-number">5.3.1</span> Initialisierung und Zugriff via Index</a></li>
<li><a href="#praktische-anwendung-von-arrays"><span class="toc-section-number">5.3.2</span> Praktische Anwendung von Arrays</a></li>
<li><a href="#kopieren-vs.-aliasing"><span class="toc-section-number">5.3.3</span> Kopieren vs. Aliasing</a></li>
<li><a href="#array-boundaries"><span class="toc-section-number">5.3.4</span> Array Boundaries</a></li>
<li><a href="#benutzer-eingabe-über-konsole-oder-gui"><span class="toc-section-number">5.3.5</span> Benutzer-Eingabe über Konsole oder GUI</a></li>
</ul></li>
<li><a href="#wdh_array"><span class="toc-section-number">5.4</span> Wiederholungsfragen</a></li>
</ul></li>
<li><a href="#elementare-algorithmen-und-laufzeit-analysen"><span class="toc-section-number">6</span> Elementare Algorithmen und Laufzeit-Analysen</a><ul>
<li><a href="#der-bubble-sort-algorithmus"><span class="toc-section-number">6.1</span> Der Bubble-Sort Algorithmus</a><ul>
<li><a href="#bubble-sort-manuell-durchspielen"><span class="toc-section-number">6.1.1</span> Bubble-Sort manuell durchspielen</a></li>
</ul></li>
<li><a href="#laufzeitanalyse"><span class="toc-section-number">6.2</span> Laufzeitanalyse</a><ul>
<li><a href="#anzahl-vergleichsoperationen"><span class="toc-section-number">6.2.1</span> Anzahl Vergleichsoperationen</a></li>
<li><a href="#aufwand-im-besten-und-im-schlechtesten-fall"><span class="toc-section-number">6.2.2</span> Aufwand im besten und im schlechtesten Fall</a></li>
<li><a href="#komplexitätsklassen-von-algorithmen"><span class="toc-section-number">6.2.3</span> Komplexitätsklassen von Algorithmen</a></li>
</ul></li>
<li><a href="#wdh_funkomplex"><span class="toc-section-number">6.3</span> Wiederholungsfragen</a></li>
</ul></li>
<li><a href="#dynamische-datenstrukturen-verkettete-liste"><span class="toc-section-number">7</span> Dynamische Datenstrukturen: Verkettete Liste</a><ul>
<li><a href="#lernziele_vk"><span class="toc-section-number">7.1</span> Lernziele</a></li>
<li><a href="#eine-elementare-datenstruktur-verkettete-liste"><span class="toc-section-number">7.2</span> Eine elementare Datenstruktur: Verkettete Liste</a><ul>
<li><a href="#implementierung"><span class="toc-section-number">7.2.1</span> Implementierung</a></li>
</ul></li>
<li><a href="#die-mylinkedlist---klasse"><span class="toc-section-number">7.3</span> Die MyLinkedList - Klasse</a><ul>
<li><a href="#elemente-hinzufügen"><span class="toc-section-number">7.3.1</span> Elemente hinzufügen:</a></li>
</ul></li>
<li><a href="#verkettete-liste-vs.-array"><span class="toc-section-number">7.4</span> Verkettete Liste vs. Array</a></li>
<li><a href="#wdh_vk"><span class="toc-section-number">7.5</span> Wiederholungsfragen</a></li>
</ul></li>
<li><a href="#dynamische-datenstrukturen-ii-stacks-und-queues"><span class="toc-section-number">8</span> Dynamische Datenstrukturen II: Stacks und Queues</a><ul>
<li><a href="#lernziele_stacks_queues"><span class="toc-section-number">8.1</span> Lernziele</a></li>
<li><a href="#die-verkettete-liste-als-stapel-speicher"><span class="toc-section-number">8.2</span> Die verkettete Liste als Stapel-Speicher</a></li>
<li><a href="#die-verkettete-liste-als-warteschlange"><span class="toc-section-number">8.3</span> Die Verkettete Liste als Warteschlange</a></li>
<li><a href="#verwendung-von-iterator-anstelle-von-for--oder-while-schleifen"><span class="toc-section-number">8.4</span> Verwendung von <code>Iterator</code> anstelle von <code>for</code>- oder <code>while</code>-Schleifen</a></li>
<li><a href="#wdh_stack_queue"><span class="toc-section-number">8.5</span> Wiederholungsfragen</a></li>
</ul></li>
<li><a href="#dynamische-datenstrukturen-iii-java-collections"><span class="toc-section-number">9</span> Dynamische Datenstrukturen III: Java Collections</a><ul>
<li><a href="#lernziele_javacollections"><span class="toc-section-number">9.1</span> Lernziele</a></li>
<li><a href="#datenstrukturen-in-java-die-collections-bibliothek"><span class="toc-section-number">9.2</span> Datenstrukturen in Java: Die Collections-Bibliothek</a></li>
<li><a href="#die-schnittstellen-collection-und-list"><span class="toc-section-number">9.3</span> Die Schnittstellen Collection und List</a></li>
<li><a href="#implementierung-der-schnittstellen-in-klassen-des-java.util-pakets"><span class="toc-section-number">9.4</span> Implementierung der Schnittstellen in Klassen des <code>java.util</code> Pakets</a></li>
</ul></li>
<li><a href="#anwendungsgebiete-von-arraylist-vector-und-linkedlist"><span class="toc-section-number">10</span> Anwendungsgebiete von <code>ArrayList</code>, <code>Vector</code> und <code>LinkedList</code></a><ul>
<li><a href="#die-foreach-schleife-mit-collections"><span class="toc-section-number">10.1</span> Die <code>foreach</code>-Schleife mit Collections</a></li>
<li><a href="#lambda-funktionen"><span class="toc-section-number">10.2</span> Lambda-Funktionen</a><ul>
<li><a href="#sortieren-von-arraylist-und-linkedlist"><span class="toc-section-number">10.2.1</span> Sortieren von <code>ArrayList</code> und <code>LinkedList</code></a></li>
<li><a href="#listen-mit-lambda-ausdrücken-filtern"><span class="toc-section-number">10.2.2</span> Listen mit Lambda-Ausdrücken filtern</a></li>
</ul></li>
<li><a href="#die-map-datenstruktur"><span class="toc-section-number">10.3</span> Die <code>Map</code>-Datenstruktur</a></li>
<li><a href="#wdh_javautils"><span class="toc-section-number">10.4</span> Wiederholungsfragen</a></li>
</ul></li>
<li><a href="#dynamische-datenstrukturen-iv-json-und-xml"><span class="toc-section-number">11</span> Dynamische Datenstrukturen IV: JSON und XML</a><ul>
<li><a href="#lernziele_xmljson"><span class="toc-section-number">11.1</span> Lernziele</a></li>
<li><a href="#die-datenstruktur-json"><span class="toc-section-number">11.2</span> Die Datenstruktur JSON</a><ul>
<li><a href="#json-mit-java-parsen"><span class="toc-section-number">11.2.1</span> JSON mit Java parsen</a></li>
<li><a href="#json-web-services-nutzen"><span class="toc-section-number">11.2.2</span> JSON – Web-Services nutzen</a></li>
</ul></li>
<li><a href="#einführung-in-xml"><span class="toc-section-number">11.3</span> Einführung in XML</a><ul>
<li><a href="#aufbau"><span class="toc-section-number">11.3.1</span> Aufbau</a></li>
<li><a href="#xml-parser"><span class="toc-section-number">11.3.2</span> XML Parser</a></li>
<li><a href="#aufgabe-aus-xml-ein-dom-erstellen"><span class="toc-section-number">11.3.3</span> Aufgabe: Aus XML ein DOM erstellen</a></li>
<li><a href="#xml-web-services-nutzen"><span class="toc-section-number">11.3.4</span> XML – Web-Services nutzen</a></li>
</ul></li>
<li><a href="#generieren-und-schreiben-von-xml-und-json"><span class="toc-section-number">11.4</span> Generieren und Schreiben von XML und JSON</a></li>
<li><a href="#wdh_xml_json"><span class="toc-section-number">11.5</span> Wiederholungsfragen</a></li>
</ul></li>
<li><a href="#rekursion-und-backtracking"><span class="toc-section-number">12</span> Rekursion und Backtracking</a><ul>
<li><a href="#lernziele_rekursion"><span class="toc-section-number">12.1</span> Lernziele</a></li>
<li><a href="#rekursion"><span class="toc-section-number">12.2</span> Rekursion</a><ul>
<li><a href="#rekursion-in-einer-datenstruktur"><span class="toc-section-number">12.2.1</span> Rekursion in einer Datenstruktur</a></li>
<li><a href="#rekursive-algorithmen"><span class="toc-section-number">12.2.2</span> Rekursive Algorithmen</a></li>
</ul></li>
<li><a href="#rekursion-vs-iteration"><span class="toc-section-number">12.3</span> Rekursion vs Iteration</a></li>
<li><a href="#backtracking"><span class="toc-section-number">12.4</span> Backtracking</a></li>
</ul></li>
</ul>
</nav>
<!--
# Requirements:
PATH=$HOME/.cabal/bin:$PATH
## numbering for figures (https://github.com/tomduck/pandoc-fignos#installation) 
pip3 install --upgrade pandoc-fignos

#BULK convert from DOCX with image export in separate directories
n=1
for x in skript*.docx; do 
mkdir media$n
pandoc -s $x -t markdown -o markdownX/$x.md --extract-media=media$n
n=$((n+1))
done
# move the pics from export to markdown directory
for i in `seq 2 10`; 
    do mkdir media$i
    cp ../media$i/media/* media$i/
done

# prepend sone string to file
echo "text"|cat - yourfile > /tmp/out && mv /tmp/out yourfile

# MD -> HTML
pandoc -s skript1ab_ersteSchritte.docx.md -o M411_book20171222.html -t html5 --toc --toc-depth 2 --filter pandoc-include -c buttondown.css -N --section -s --mathml --self-contained --filter pandoc-fignos; cp M411_book.html ~/Desktop/WISS/Modul_411/IFZ_524_ZH/m411_skript/


pandoc -s skrip*ueb*.md -o M411_toolbox.html -t html5 --toc --toc-depth 2 --filter pandoc-include -c buttondown.css --section -s --mathml


# -s: Header (Title, etc)
# -section: put chapters in <section> elements
-->
<!-----
pandoc_title_block
%title:'This is the title: it contains a colon'
%author:
%- name: Author One
  affiliation: University of Somewhere
%- name: Author Two
  affiliation: University of Nowhere
-->
<article>
<section id="willkommen-zurück-bei-in-java" class="level1">
<h1><span class="header-section-number">1</span> Willkommen (zurück) bei in Java</h1>
<p>In der Informatiker-Welt läuft nichts ohne Datenstrukturen und Algorithmen. Eine einfache Bitmap-Datei beispielsweise besteht aus einer (meist) dreidimensionalen Tabelle bzw. Feld. Unkomprimierte Audio-Dateien enthalten ebenfalls Felder. In diesem Modul lernen Sie verschiedene komplexe Datenstrukturen und deren grundlegende Eigenschaften kennen. Mit diesem Wissen können Sie wichtige Entscheidungen für Ihre eigenen Software-Projekte treffen.</p>
<p>In diesem Modul werden wir mit der Programmiersprache Java SE 8 arbeiten. Vorausgesetzt werden gute Kenntnisse aus den Modulen 403 (Prozedurale Programmierung) und 226A+B (Objektorientierte Programmierung). Sie können frei wählen, mit welcher Entwicklungsumgebung Sie arbeiten. Zur Abschlussprüfung werden Sie jedoch Eclipse einsetzen.</p>
<p>Zur Verwaltung der Datenstrukturen werden spezielle Funktionen bzw. Algorithmen benötigt. Wichtige Beispiele sind Such- und Sortier-Algorithmen. Wie immer in der Informatik gibt es verschiedene Wege, solche Algorithmen zu programmieren, und entsprechend kann die Laufzeit stark variieren. Sie lernen, einfache Sortier-Algorithmen selbst zu implementieren und deren Rechenzeit abzuschätzen.</p>
<p>Die meisten Programmiersprachen liefern häufig benötigte Datenstrukturen und die dazugehörigen Algorithmen gleich mit. Damit wird der Aufwand für die Implementierung und das Testen in der Software-Entwicklung massiv reduziert. In der Programmiersprache Java sind diese Datenstrukturen im Paket <code>java.utils</code> implementiert.</p>
<p>Abschliessend werden wichtige moderne Datenstrukturen und dafür benötigte Methoden vorgestellt. Sie kommunizieren mit Web-Services und lernen die wichtigsten Datenformate des Internets und deren Auswertefunktionen kennen.</p>
<section id="wichtige-hinweise-für-lernende" class="level2">
<h2><span class="header-section-number">1.1</span> Wichtige Hinweise für Lernende</h2>
<p>Programmieren lernt man nicht nur vom Zuhören, sondern insbesondere vom selbstständigen (und häufigen) Ausprobieren, Anwenden. Fehler machen gehört dazu, aus denen lernen Sie am meisten. Ihren Erfolg können Sie sichern, indem Sie alle Übungsaufgaben zuhause selbstständig nach den entsprechenden Lektionen bearbeiten. Übung macht den Meister!</p>
<p>Die Aufgaben sind normalerweise für Konsolen-Anwendungen gestellt, weil diese schneller zu erstellen sind. Insbesondere die erstellten Klassen späterer Aufgaben können Sie leicht in eigene <em>SWING</em> oder <em>Java-FX</em> GUIs einbinden.</p>
<p>Dokumentieren Sie Ihren Quellcode von Anfang an JavaDoc-kompatibel, wie im Beispiel beschrieben. Damit haben Sie später eine Chance, Ihre brillanten Ideen wieder zu verstehen :-)</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">/** </span>
<span class="co">    Genius provides the answer to the question of Life, the Universe and everything</span>
<span class="co">*/</span>
<span class="kw">public</span> <span class="kw">class</span> Genius{

    <span class="co">/**</span>
<span class="co">     * answers a question.</span>
<span class="co">     * </span><span class="kw">@param question </span><span class="co">is the query</span>
<span class="co">     * </span><span class="kw">@return </span><span class="co">the answer to the question of Life, the Universe and everything</span>
<span class="co">     */</span>
    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">answerQuestion</span>(<span class="bu">String</span> question){
    <span class="bu">System</span>.<span class="fu">sleep</span>(<span class="fl">7.5e6</span> * <span class="dv">365</span> * <span class="dv">24</span> * <span class="dv">60</span> * <span class="dv">60</span> * <span class="dv">1000</span>); <span class="co">// wait 7.5 Mio years</span>
        <span class="kw">return</span> <span class="dv">42</span>;  
    }
}</code></pre></div>
</section>
<section id="handlungsziele-nach-ict-vorgaben-bivo-2014" class="level2">
<h2><span class="header-section-number">1.2</span> Handlungsziele nach ICT-Vorgaben (BiVo 2014)</h2>
<ol type="1">
<li><strong>Für ein gegebenes Problem eine geeignete Datenstruktur definieren und mit den Mitteln einer Programmiersprache, wie Structs, Referenzen / Zeiger und Arrays umsetzen.</strong><br />
</li>
</ol>
<ul>
<li>Kennt den Unterschied zwischen Wertevariablen und Referenzvariablen / Zeigervariablen.</li>
<li>Kennt Sprachmittel einer Programmiersprache für das Deklarieren und das Arbeiten mit Werte- und Referenzvariablen.</li>
<li>Kennt Konzept und Nutzen von verketteten Datenstrukturen.</li>
<li>Kennt eine Notation für die Darstellung von verketteten Datenstrukturen.
<hr/></li>
</ul>
<ol start="2" type="1">
<li><strong>Ein Problem analysieren und einen geeigneten Algorithmus zur Lösung mit den Grundelementen Zuweisung, Verzweigung und Schleife entwerfen und mit Prozeduren und Funktionen umsetzen.</strong></li>
</ol>
<ul>
<li>Kennt eine systematische Vorgehensweise für die Analyse eines Problems.</li>
<li>Kennt die Grundelemente von Algorithmen und deren Umsetzung in einer Programmiersprache.</li>
<li>Kennt die Sprachmittel einer Programmiersprache für das Deklarieren und Aufrufen von Funktionen und Prozeduren.</li>
<li>Kennt Notationen um Algorithmen darzustellen wie z.B. Struktogrammen, PAP usw.
<hr/></li>
</ul>
<ol start="3" type="1">
<li><strong>Algorithmen und Datenstrukturen hinsichtlich Speicher- und Zeitkomplexität analysieren und dokumentieren.</strong><br />
</li>
</ol>
<ul>
<li>Kennt Möglichkeiten zur Analyse von Zeit- und Speicherkomplexität von Algorithmen und Datenstrukturen.</li>
<li>Kennt Komplexitätsklassen von Algorithmen (z.B. lineare, exponentielle Komplexität).</li>
<li>Kennt Notationen zur Dokumentation der Speicher- und Zeitkomplexität eines Algorithmus.
<hr/></li>
</ul>
<ol start="4" type="1">
<li><strong>Ein komplexeres Problem auf kleinere Teilprobleme zurückführen und je nach Problemstellung Iteration oder Rekursion einsetzen.</strong><br />
</li>
</ol>
<ul>
<li>Kennt ein Vorgehen bei der Aufteilung eines komplexen Problems in kleinere Teilprobleme.</li>
<li>Kennt den Aufbau von iterativen Algorithmen.</li>
<li>Kennt den Aufbau von rekursiven Algorithmen.</li>
<li>Kennt Vor- und Nachteile sowie geeignete Einsatzgebiete des iterativen und des rekursiven Ansatzes.
<hr/></li>
</ul>
<ol start="5" type="1">
<li><strong>Abstrakte Datentypen, wie Liste, Set, Map etc. und die darauf definierten Operationen kennen und zielgerichtet einsetzen können.</strong><br />
</li>
</ol>
<ul>
<li>Kennt eine Programmbibliothek, die ADTs wie Liste, Set, Map, etc. zur Verfügung stellt und deren Anwendung.</li>
<li>Kennt Eigenschaften von einzelnen abstrakten Datentypen.
<hr/></li>
</ul>
<ol start="6" type="1">
<li><strong>Datenstrukturen und Algorithmen mit dem Debugger und weiteren Tools untersuchen und dabei speziell die Situation auf Stack und Heap Analysieren und in geeigneter Form darstellen.</strong><br />
</li>
</ol>
<ul>
<li>Kennt das Speicherlayout für einen Prozess mit den Bereichen Programmcode, globale Variablen, Stack und Heap.</li>
<li>Kennt die Anordnung von lokalen Variablen und Parametern in einem Stackframe.</li>
<li>Kennt die Funktionsweise des Stacks bei einem Funktionsaufruf.</li>
<li>Kennt die Funktionsweise im Heap bei dynamisch erzeugten Objekten.</li>
<li>Kennt die Anwendung eines Debuggers für die Untersuchung von Heap und Stack zur Laufzeit und/oder ein Tool zur Laufzeitanalyse für Grössen wie Memory Leaks, Aufrufhäufigkeit und Verweildauer von Funktionen, etc.
<hr/></li>
</ul>
</section>
<section id="kursablauf" class="level2">
<h2><span class="header-section-number">1.3</span> Kursablauf</h2>
<p>Die 40 zur Verfügung stehenden Lektionen können wie folgt aufgeteilt werden:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Block</th>
<th style="text-align: left;">Thema</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Lektion 1 -4</strong></td>
<td style="text-align: left;">- einfache Klassen; main Methode</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">- Eingabe-/Ausgabe für Konsole und Dateien</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 71%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p><strong>Lektion 5 – 10</strong></p></td>
<td><ul>
<li>Arrays</li>
<li>Sortier-Algorithmen</li>
<li>Laufzeitkomplexität</li>
</ul></td>
</tr>
<tr class="even">
<td><p><strong>Lektion 11 – 16</strong></p></td>
<td><ul>
<li>Verkettete Liste</li>
<li>Iteratoren, Template-Klassen</li>
</ul></td>
</tr>
<tr class="odd">
<td><p><strong>Lektion 17 – 20</strong></p></td>
<td><ul>
<li>Stack, Queue</li>
<li>Java Collections und HashMaps</li>
<li>HashMaps</li>
</ul></td>
</tr>
<tr class="even">
<td><p><strong>Lektion 21 – 24</strong> <strong>Lektion 25 – 32</strong> <strong>Lektion 33 – 36</strong></p></td>
<td><ul>
<li>Miniprojekt</li>
<li>Rekursion (Übung SnippetSearch)</li>
<li>JSON mit Web-Services</li>
<li>optional XML</li>
</ul></td>
</tr>
<tr class="odd">
<td><p><strong>Lektion 37 – 40</strong></p></td>
<td><ul>
<li>LB</li>
<li>Review Modul</li>
</ul></td>
</tr>
</tbody>
</table>
</section>
<section id="hinweis-für-verbesserungen" class="level2">
<h2><span class="header-section-number">1.4</span> Hinweis für Verbesserungen</h2>
<p>Für Hinweise und Verbesserungsvorschläge besuchen Sie bitte das entsprechende Github-Projekt unter <a href="https://github.com/greenorca/ICT_EFZ_API_M411" class="uri">https://github.com/greenorca/ICT_EFZ_API_M411</a>.</p>
<p>Die Lösungsskripte werden nur für Dozenten zur Verfügung gestellt.</p>
</section>
</section>
<section id="klassen-erstellen" class="level1">
<h1><span class="header-section-number">2</span> Klassen erstellen</h1>
<section id="lernziele" class="level2">
<h2><span class="header-section-number">2.1</span> Lernziele</h2>
<ul>
<li>Sie erstellen einfache Java-Klassen Ihrer vertrauten Entwicklungsumgebung</li>
<li>Sie lesen Daten von der Konsole ein und geben Daten auf der Konsole aus</li>
<li>Sie können verschiedene Datenformate von Textdateien einlesen und schreiben</li>
</ul>
</section>
<section id="die-main-methode" class="level2">
<h2><span class="header-section-number">2.2</span> Die main-Methode</h2>
<p>Hier ist der Code einer kleinen Java-Klasse, welche zum Begrüssen verschiedener Personen verwendet werden kann:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> WelcomeMessage{

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">sayHello</span>(<span class="bu">String</span> name){
        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Welcome &quot;</span>+ name);
    } 
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args){
        WelcomeMessage msg = <span class="kw">new</span> <span class="fu">WelcomeMessage</span>();
        msg.<span class="fu">sayHello</span>(<span class="st">&quot;Tom&quot;</span>);
        msg.<span class="fu">sayHello</span>(<span class="st">&quot;Mirjam&quot;</span>);
    }
}</code></pre></div>
<p>Ein Java-Programm wird immer so ausgeführt, dass die main-Methode einer bestimmten Klasse aufgerufen wird. Diese muss genau so deklariert sein, wie Sie der ersten Zeile sehen. In der main-Methode (ein neuer Name für Funktion) wird dann üblicherweise ein Objekt erzeugt, in unserem Beispiel in Zeile 7. Von diesem Objekt werden dann Methoden aufgerufen, z.B. Zeile 8 und 9.</p>
</section>
<section id="übung-java-ide-und-ein-ausgaben" class="level2">
<h2><span class="header-section-number">2.3</span> Übung: Java IDE und Ein-/Ausgaben</h2>
<p><strong>Lernziele:</strong></p>
<ul>
<li>Beherrschen des Umgangs mit einer Entwicklungsumgebung</li>
<li>Einlesen und verarbeiten von Benutzer-Eingaben</li>
</ul>
<p><strong>Zeit:</strong> 45 Minuten</p>
<p>Erstellen Sie in Ihrer Entwicklungsumgebung ein neues Java-Projekt mit dem Namen <code>M411</code>. In diesem Projekt erstellen Sie alle folgenden Klassen.</p>
<ul>
<li><p>Erstellen Sie eine Java-Klasse <code>WelcomeMessage</code> gemäss dem Beispiel. Achten Sie darauf, das der Dateiname dem Klassennamen entspricht.</p></li>
<li><p>Erweitern Sie die Klasse <code>WelcomeMessage</code> so, dass es eine zweite Methode gibt, welche eine Person verabschiedet. Erweitern Sie dann auch die main-Methode so, dass zuerst zwei Personen begrüsst und dann in umgekehrter Reihenfolge verabschiedet werden. Speichern Sie die Personennamen in geeigneten lokalen Variablen ab und übergeben Sie nur die Variablen an die Funktionen.</p></li>
<li><p>Erstellen Sie eine Methode, welche so parametrisiert ist, dass sie von beiden vor­handenen Methoden verwendet werden kann, um die korrekte Meldung auszugeben. Es soll dann im ganzen Programm nur noch einmal der Aufruf von <code>System.out.println</code> vorkommen.</p></li>
</ul>
<p><lsg> <strong>Lösungsvorschlag</strong></p>
<p><code>WelcomeMessage.java</code></p>
<p></lsg></p>
</section>
</section>
<section id="ein--und-ausgabe-über-die-konsole" class="level1">
<h1><span class="header-section-number">3</span> Ein- und Ausgabe über die Konsole</h1>
<section id="ausgabe" class="level2">
<h2><span class="header-section-number">3.1</span> Ausgabe</h2>
<p>Im obigen kleinen Beispiel haben Sie schon gesehen, wie Text auf der Konsole ausgegeben werden kann, nämlich mit der Methode <code>System.out.println</code>. Vielleicht ist Ihnen auch aufgefallen, wie Texte einfach mit <code>+</code> zusammengesetzt werden. Das Gleiche gilt auch für Zahlenwerte, wie das folgende Beispiel zeigt:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> a = <span class="dv">5</span>;
<span class="dt">int</span> b = <span class="dv">6</span>;

<span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Die Summe von &quot;</span> + a + <span class="st">&quot; und &quot;</span> + b + <span class="st">&quot; ist &quot;</span> + (a+b));</code></pre></div>
<p>Wie sieht die Ausgabe aus, wenn Sie beim Ausdruck <code>(a+b)</code> die Klammern weglassen? Probieren Sie das aus und erklären Sie Ihre Beobachtungen.</p>
</section>
<section id="eingabe" class="level2">
<h2><span class="header-section-number">3.2</span> Eingabe</h2>
<p>Um Texte oder Zahlen von der Konsole einzulesen, müssen wir ein Objekt der Klasse <code>Scanner</code> (das ist eine Klasse aus der Standard Java-Library) erzeugen. Dieses Objekt gibt uns dann auf Aufforderung hin den nächsten Text oder die nächste Zahl:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="bu">Scanner</span> scan = <span class="kw">new</span> <span class="bu">Scanner</span>(<span class="bu">System</span>.<span class="fu">in</span>);
<span class="dt">int</span> a = scan.<span class="fu">nextInt</span>();
<span class="bu">String</span> s = scan.<span class="fu">next</span>();</code></pre></div>
</section>
<section id="übung-numerische-ein-ausgaben" class="level2">
<h2><span class="header-section-number">3.3</span> Übung: Numerische Ein-/Ausgaben</h2>
<p><strong>Lernziele:</strong></p>
<ul>
<li>Einlesen und verarbeiten von Benutzer-Eingaben</li>
<li>Einlesen von Zahlenformaten</li>
<li>Arbeiten mit <code>Java-Calendar</code> Klassen.</li>
</ul>
<p><strong>Zeit:</strong> 60 Minuten</p>
<ul>
<li><p>Suchen Sie im Internet oder in der Java-Hilfe Informationen zur <code>Calendar</code>-Klasse. Geben Sie zunächst das aktuelle Datum zeilenweise aus: zuerst das Jahr, dann den Monat und schliesslich den Tag und Wochentag. Vermeiden Sie die Benutzung von <code>deprecated</code>-Funktionen.</p></li>
<li><p>Erstellen Sie eine Klasse <code>AgeCalculator</code> mit der Methode <code>public void tellAge()</code>. Diese Methode soll den Benutzer nach seinem Namen und seinem Jahrgang und Geburtsmonat fragen. Wenn der Geburtsmonat dem aktuellen Monat entspricht, soll zusätzlich nach dem Geburtstag gefragt werden. Im Anschluss wird die folgende Meldung ausgeben:</p>
<p><code>Hallo Peter, du wirst in diesem Jahr 34 Jahre alt.</code></p>
<p>Dabei soll der Name und das Alter den Benutzer-Eingaben entsprechen. Verwenden Sie für die Berechnung des Alters das aktuelle Datum aus der <code>Calendar</code>-Klasse.</p></li>
</ul>
<p>Erstellen Sie zunächst ein Struktogramm für die Funktion <code>tellAge()</code>. Dann implementieren und testen Sie Ihre Funktion.</p>
<p><lsg> <strong>Lösungsvorschlag</strong></p>
<p><code>AgeCalculator.java</code></p>
<p></lsg></p>
<p>Quelle: BBW Unterlagen, St.Dütsch. August 2015</p>
</section>
</section>
<section id="strukturiere-daten-lesen-und-schreiben" class="level1">
<h1><span class="header-section-number">4</span> Strukturiere Daten lesen und schreiben</h1>
<section id="lernziele_file_io" class="level2">
<h2><span class="header-section-number">4.1</span> Lernziele</h2>
<ul>
<li>Sie können in einem Programm aus einem File Daten lesen</li>
<li>Strukturierte Textzeilen zerlegen und diese in geeignete Datenobjekte abfüllen</li>
<li>Ausgaben in Textfiles durch Formatierung strukturieren</li>
</ul>
</section>
<section id="bufferedreader" class="level2">
<h2><span class="header-section-number">4.2</span> BufferedReader</h2>
<p>Wir werden uns hier zunächst nur mit Text Files beschäftigen, welche eine <em>Zeilenstruktur</em> aufweisen, in denen also Informationseinheiten durch einen Zeilenumbruch voneinander getrennt sind.</p>
<p>Die Klasse <code>BufferedReader</code> aus der <em>Java Library</em> stellt die Methode <code>readLine()</code> mit dem Rückgabetyp String zur Verfügung.</p>
<p>Diese Methode liefert immer jeweils die nächste ungelesene Zeile von der aktuellen Quelle des Readers. Wenn keine Zeilen mehr vorhanden sind gibt readLine den Wert null zurück.</p>
<p>Nehmen Sie an, Sie haben in der Variablen <code>br</code> ein <code>BufferedReader</code>-Objekt. Wie könnte eine Schleife aussehen, welche alle Zeilen einliest und auf der Konsole ausgibt?</p>
<section id="erstellen-eines-bufferedreader" class="level3">
<h3><span class="header-section-number">4.2.1</span> Erstellen eines BufferedReader</h3>
<p>Zum Instantiieren eines <code>BufferedReader</code>-Objekts müssen wir im Konstruktor angeben, von welcher Quelle gelesen werden soll. In unserem Fall sollen Text-Dateien gelesen werden. Entsprechend ist die Quelle ein <code>FileReader</code>-Objekt. Der Konstruktor der <code>FileReader</code>-Klasse erfordert den Pfad zum zu lesenden File als String. Mit der Instanz des <code>FileReader</code> als Parameter erstellen wir zunächst eine <code>BufferedReader</code> Instanz.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="bu">String</span> fileName = <span class="st">&quot;C:</span><span class="sc">\t</span><span class="st">mp\daten.csv&quot;</span>;

<span class="kw">try</span>{
    <span class="bu">FileReader</span> fr = <span class="kw">new</span> <span class="bu">FileReader</span>(fileName);
    <span class="bu">BufferedReader</span> br = <span class="kw">new</span> <span class="bu">BufferedReader</span>(fr);
    <span class="co">//....</span>
}
<span class="kw">catch</span>(<span class="bu">FileNotFoundException</span> ioex){ 
    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Datei &quot;</span>+fileName+<span class="st">&quot; not found&quot;</span>);
}</code></pre></div>
<p>Die Verwendung des <code>FileReader</code> kann zu Ausnahmesituationen (<code>Exceptions</code>) führen, wenn die angegebene Datei nicht lesbar ist. Setzen Sie Ihren Code entsprechende in einen <code>try-catch</code>-Block (zu Exceptions ausführlich mehr später).</p>
</section>
<section id="bufferedreader-oder-scanner" class="level3">
<h3><span class="header-section-number">4.2.2</span> BufferedReader oder Scanner?</h3>
<p>Neben dem <code>BufferedReader</code> kann man auch die <code>Scanner</code> Klasse verwenden. Die Effizienz beim Einlesen von einem File ist ungefähr dieselbe. Die Scanner-Klasse bietet weitere Methoden, um das Parsen (das „Strukturieren“ eines Input-Streams) besser zu bewältigen. Jedoch ist Scanner nicht „thread safe“. Das heisst, gleichzeitige Dateizugriffe müssen von aussen vermieden werden.</p>
<p>Die Scanner-Klasse eignet sich hervorragend, um Benutzer-Eingaben via Konsole einzulesen. Siehe auch die InputReader Klasse. Sie können gerne beide Varianten für das Einlesen von Files ausprobieren.</p>
Die Unterschiede beim Einlesen einzelner Zeilen aus Text-Dateien sind:
<table>
<tr>
<th>
Scanner
</th>
<th>
BufferedReader
</th>
</tr>
<tr>
<td>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="bu">Scanner</span> input = <span class="kw">null</span>;
<span class="kw">try</span> {
 <span class="bu">File</span> f = <span class="kw">new</span> <span class="bu">File</span>(<span class="st">&quot;C:/tmp/1.csv&quot;</span>);
 input = <span class="kw">new</span> <span class="bu">Scanner</span>(file);
 <span class="kw">while</span> (input.<span class="fu">hasNextLine</span>()) {
  <span class="bu">String</span> line = input.<span class="fu">nextLine</span>();
  <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(line);
 }
 input.<span class="fu">close</span>();
} 
<span class="kw">catch</span> (<span class="bu">Exception</span> ex) {
 ex.<span class="fu">printStackTrace</span>(); 
} </code></pre></div>
</td>
<td>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="bu">BufferedReader</span> bfr = <span class="kw">null</span>;
<span class="kw">try</span> {
 <span class="bu">String</span> inputLine;
 <span class="bu">String</span> file = <span class="st">&quot;C:/tmp/daten.csv&quot;</span>;
 <span class="bu">FileReader</span> fr = <span class="kw">new</span> <span class="bu">FileReader</span>(file);
 bfr = <span class="kw">new</span> <span class="bu">BufferedReader</span>(fr);

 <span class="kw">while</span> ((inputLine = bfr.<span class="fu">readLine</span>()) != <span class="kw">null</span>) {
   <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(inputLine);
 }
    
} 
<span class="kw">catch</span> (<span class="bu">IOException</span> e) {
   e.<span class="fu">printStackTrace</span>();
} 
<span class="kw">finally</span> {
 <span class="kw">try</span> {
  <span class="kw">if</span> (bfr != <span class="kw">null</span>) {
       bfr.<span class="fu">close</span>();
  }
 } 
 <span class="kw">catch</span> (<span class="bu">IOException</span> ex) {
   ex.<span class="fu">printStackTrace</span>();
 }
}</code></pre></div>
</td>
</tr>
</table>
<p>Zum Erstellen einer <code>Scanner</code> Instanz verwenden Sie ein <code>File</code>-Objekt. Der Konstruktor von <code>BufferedReader</code> verwendet einen <code>FileReader</code>. Bei beiden Varianten wird das File zeilenweise in je ein <code>String</code>-Objekt eingelesen.</p>
<p>Beiden Varianten beenden das Lesen mit der Methode <code>close()</code>, um den Dateizugriff wieder freizugeben und den Eingabestrom zu schliessen.</p>
<p>Beachten Sie, dass die Objekte <code>input</code> und <code>bfr</code> bereits vor dem <code>try</code>-Block angelegt werden und damit die Sichtbarkeit dieser Objekte ausserhalb des <code>try</code> sicherzustellen.</p>
</section>
</section>
<section id="strukturierte-textfiles" class="level2">
<h2><span class="header-section-number">4.3</span> Strukturierte Textfiles</h2>
<p>Oft werden Daten strukturiert in lesbaren Text-Dateien abgelegt. So können zum Beispiel Excel-Tabellen oder Datenbank-Abfragen im CSV-Format gespeichert werden, so dass jede Zeile der Tabelle eine Zeile im Text File ergibt. Innerhalb der Zeilen sind die Spalten durch ein spezielles Trennzeichen getrennt (CSV steht für <em>Comma Separated Values</em>). Ausser dem Komma sind das Semikolon oder ein Tabulator gebräuchliche Trennzeichen.</p>
<p>Eine CSV Datei mit Personendaten kann beispielsweise so aussehen:</p>
<pre><code>Huber;Peter;1955
Meier;Irene;1960
Muster;Anna;1974</code></pre>
<p>Nach dem Auslesen einer Zeile wird der String, welcher eine Zeile enthält, mit der <code>lineSplit()</code> Methode zerlegt.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="bu">String</span> line = <span class="st">&quot;Huber;Peter;1955&quot;</span>;        <span class="co">// contains one line which must be processed</span>
<span class="bu">String</span>[] lineParts = line.<span class="fu">split</span>(<span class="st">&quot;;&quot;</span>);    <span class="co">// split line at occurences of semicolon</span>
<span class="co">// loop over all parts of the line</span>
<span class="kw">for</span> (<span class="bu">String</span> p: lineParts ) {
    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(p);
}</code></pre></div>
<section id="nummerische-werte-behandeln" class="level3">
<h3><span class="header-section-number">4.3.1</span> Nummerische Werte behandeln</h3>
<p>Auch Zahlen (im Beispiel das Geburtsjahr) werden zunächst als String eingelesen, wie alle anderen Zeichenketten auch. Solange wir damit nicht rechnen wollen, spielt das auch keine Rolle. Meistens ist aber nötig, diese Felder in richtig Zahlen umzuwandeln. Dazu dienen die entsprechenden <code>parse</code>-Methoden der Klassen <code>Integer</code> und <code>Double</code>:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="bu">String</span> x = <span class="st">&quot;42&quot;</span>;
<span class="bu">String</span> y = <span class="st">&quot;3.14&quot;</span>;
<span class="dt">int</span> intVal = <span class="bu">Integer</span>.<span class="fu">parseInt</span>(x);
<span class="dt">double</span> doubleVal = <span class="bu">Double</span>.<span class="fu">parseDouble</span>(doubleStr);</code></pre></div>
</section>
</section>
<section id="übung-textdateien-einlesen" class="level2">
<h2><span class="header-section-number">4.4</span> Übung: Textdateien einlesen</h2>
<p><strong>Lernziele:</strong></p>
<ul>
<li>Erstellen einer Klasse zum zeilenweisen Lesen von Textdateien</li>
<li>Konvertieren von Textzeilen zu Datenobjekten</li>
<li>Vergleichen von Strings</li>
<li>Umwandeln von String in numerische Datentypen</li>
</ul>
<p><strong>Zeit:</strong> 45 Minuten</p>
<p>Wir werden eine Textdatei mit folgender Struktur verwenden:</p>
<pre><code>Huber;Peter;1955
Meier;Irene;1960
Muster;Anna;1974
Kohli;Jan;1998
Manser;Mario;1999</code></pre>
<p>Speichern Sie obigen Text als Datei im Projektordner mit dem Namen <code>daten.csv</code> ab.</p>
<ol type="1">
<li><p>Erstellen Sie eine neue Java-Klasse <code>Skript1_SimpleCsvReader</code> im Projekt <code>M411</code>, welches diese Datei liest und Zeile für Zeile wieder auf der Konsole ausgibt. Geben Sie zusätzlich das Alter der Personen jeweils am Ende der Zeile aus.</p>
<p><strong>Lösungsvorschlag:</strong></p>
<p><code>Skript1_SimpleCsvReader.java</code></p></li>
<li><p>Erstellen Sie eine Klasse Person mit den <em>private</em> Attributen bzw. Instanzvariablen <code>name</code>, <code>vorname</code> (String) und <code>geburtsjahr</code> (int). Die Parameter sollen im Konstruktor übergeben werden. Zusätzlich erstellen Sie die notwendigen <em>GETTER</em> Funktionen für die Instanzvariablen.</p></li>
</ol>
<p>Sorgen Sie nun in der <code>main()</code>-Methode von <code>Skript1_SimpleCsvReader</code> dafür, dass für jede Zeile der Datei <code>daten.csv</code> ein entsprechendes Objekt vom Typ <code>Person</code> angelegt wird. Prüfen Sie die Richtigkeit der erstellten Objekte manuell innerhalb der Schleife zum Einlesen.</p>
<ol start="3" type="1">
<li><p>Kopieren Sie die Klasse <code>Skript1_SimpleCsvReader</code> und nennen Sie die Kopie <code>Skript1_SearchCsvReader</code>. Erweitern Sie die Klasse so, dass zuerst der Benutzer einem Vornamen eingibt. Dann wird die Datei <code>daten.csv</code> eingelesenen und von allen Personen mit diesem Vornamen der ganze Namen und das Alter auf der Konsole ausgegeben. Beachten Sie dabei, dass zum Vergleich von zwei String-Variablen der Operator <code>==</code> <strong>nicht</strong> verwendet werden kann. Stattdessen verwenden Sie die Methode <code>equals()</code> der Klasse <code>String</code>.</p>
<p><strong>Lösungsvorschlag:</strong></p>
<p><code>Skript1_SearchCsvReader.java</code></p></li>
</ol>
</section>
<section id="daten-strukturiert-in-ein-file-schreiben" class="level2">
<h2><span class="header-section-number">4.5</span> Daten strukturiert in ein File schreiben</h2>
<p>Die geeignetste Klasse zum Schreiben von Textdateien ist <code>PrintWriter</code>. Einem neuen <code>PrintWriter-Objekt</code> wird beim Erstellen ein String mit dem Pfad und Dateinamen oder ein <code>File</code>-Objekt übergeben. Das Objekt stellt die Methode <code>write</code> zur Verfügung. Diese ähnelt der Klasse <code>PrintStream</code>, mit der Sie beispielsweise bei <code>System.out.println</code> arbeiten.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {
    <span class="kw">try</span> {
        <span class="bu">PrintWriter</span> prnt = <span class="kw">new</span> <span class="bu">PrintWriter</span>(<span class="st">&quot;/tmp/gugus.txt&quot;</span>);   
        <span class="bu">String</span>[] names = {<span class="st">&quot;Alpha&quot;</span>,<span class="st">&quot;Beta&quot;</span>,<span class="st">&quot;Gaga&quot;</span>};
        <span class="dt">int</span> i = <span class="dv">0</span>;
        <span class="kw">for</span> (<span class="bu">String</span> n : names){
            prnt.<span class="fu">write</span>(<span class="st">&quot;&quot;</span>+i+<span class="st">&quot;;&quot;</span>+n+<span class="bu">System</span>.<span class="fu">lineSeparator</span>());
            i++;
        }
        prnt.<span class="fu">close</span>();
    } <span class="kw">catch</span> (<span class="bu">IOException</span> e) {
        e.<span class="fu">printStackTrace</span>();
    }
}</code></pre></div>
</section>
<section id="übung-csv-schreiben" class="level2">
<h2><span class="header-section-number">4.6</span> Übung: CSV schreiben</h2>
<p><strong>Lernziele</strong></p>
<ul>
<li>Vertiefen der Lese- und Schreiboperationen mit Java</li>
</ul>
<p><strong>Zeit:</strong> 25 Minuten</p>
<p><strong>Aufgabe</strong></p>
<ol type="1">
<li><p>Erstellen Sie eine Klasse <code>Skript1_MyWriter</code>. In der <code>main</code>-Funktion wird <strong>eine</strong> beliebige Benutzer-Eingabe von der Konsole eingelesen. Diese Text soll jeweils am Anfang einer Textdatei als neue Zeile einfügt werden.</p></li>
<li><p>Erweitern Sie die <code>main()</code> so, dass:</p>
<ol type="1">
<li>ein neuer Benutzer angelegt wird</li>
<li>der neue Benutzer in der <code>daten.csv</code> angehangen wird</li>
</ol></li>
</ol>
<p>Was passiert, wenn Sie einfach das Person-Objekt selbst in die Datei schreiben? Was müssen Sie tun, damit die Attribute des Objekts in die Datei geschrieben werden?</p>
<p><strong>Lösungsvorschlag:</strong></p>
<p><code>Skript1_MyWriter.java</code></p>
</section>
<section id="wdh_intro" class="level2">
<h2><span class="header-section-number">4.7</span> Wiederholungsfragen</h2>
<ol type="1">
<li>Welche Methode einer Klasse wird beim Start des Programms zuerst aufgerufen?</li>
<li>Wie können Sie eine Anzahl Attribute für ein bestimmtes Objekt schon beim Erstellen übergeben?</li>
<li>Welche Klassen helfen Ihnen, Konsoleneingaben und Textdateien zu lesen?</li>
<li>Wie transformieren Sie <code>String x = 42;</code> als Ganzzahl oder Gleitkomma-Zahlenwert?</li>
</ol>
<p><a href="#TOC">Zurück zum Inhaltsverzeichnis</a></p>
</section>
</section>
<section id="arrays" class="level1">
<h1><span class="header-section-number">5</span> Arrays</h1>
<section id="lernziele_array" class="level2">
<h2><span class="header-section-number">5.1</span> Lernziele</h2>
<ul>
<li>Sie verstehen und erklären die Begriffe Algorithmen und Datenstrukturen</li>
<li>Sie wenden die elementare Datenstruktur &quot;Array&quot; an</li>
<li>Sie beschreiben den Unterschied zwischen Zeiger- und Referenzvariablen</li>
</ul>
</section>
<section id="was-haben-algorithmen-und-datenstrukturen-miteinander-zu-tun" class="level2">
<h2><span class="header-section-number">5.2</span> Was haben Algorithmen und Datenstrukturen miteinander zu tun?</h2>
<p>Der Begriff <em>Algorithmus</em> wird in der Informatik verwendet, um ein Verfahren zur Lösung eines Problems zu beschreiben. Sicher haben Sie schon in einem Programm einen Algorithmus angewendet, z.B. zum Sortieren oder Durchsuchen von Datenbank-Tabellen. Algorithmen sind der <em>Stoff</em> der Informatik. Sie definieren das Vorgehen, um ein bestimmtes Problem zu lösen.</p>
<p>Eine <em>Datenstruktur</em> ist wichtig für den Algorithmus. Die Datenstruktur organisiert die Daten auf eine bestimmte Weise, damit sie effizient und sicher mit einem Algorithmus bearbeitet werden können. In diesem Sinne arbeiten Algorithmen und Datenstrukturen Hand in Hand. Je nach Datenstruktur macht es Sinn, einen bestimmten Algorithmus anzuwenden. Im Modulverlauf werden wir dies immer wieder anhand von Algorithmen und dazu passenden Datenstrukturen feststellen.</p>
<p>Wie bei jedem Handwerk (und ja, auch Programmieren ist ein Handwerk), gibt es sinnvolle Werkzeuge und passende Verfahren oder Arbeitsschritte, um etwas herzustellen. Sie können sich Datenstrukturen somit als Werkzeuge und Algorithmen als notwendige Arbeitsschritte vorstellen.</p>
</section>
<section id="die-elementare-datenstruktur-array" class="level2">
<h2><span class="header-section-number">5.3</span> Die elementare Datenstruktur: Array</h2>
<p>Eine wichtige elementare Datenstruktur haben Sie bereits kennengelernt: das Feld oder Array. Ein <strong>Array ist eine feste Anzahl von einzelnen Daten eines bestimmten Datentyps</strong>, welche zusammenhängend gespeichert werden und über einen Index zugänglich sind. Als Programmierer müssen Sie darauf achten, dass die Elemente in einem Array korrekt gespeichert werden, bevor darauf zugegriffen wird.</p>
<section id="initialisierung-und-zugriff-via-index" class="level3">
<h3><span class="header-section-number">5.3.1</span> Initialisierung und Zugriff via Index</h3>
<p>Zum Anlegen einer Array-Variable schreibt man den gewünschten Datentyp gefolgt von einer öffnenden und schliessenden eckigen Klammer, und danach den gewünschten Variablennamen.</p>
<p>Möglich sind zwei Arten der Initialisierung:</p>
<p><code>Datentyp varName = new Datentyp[n];</code> // wobei <code>n</code> die Anzahl der Elemente ist. Damit ist der Speicherbereich des Arrays festgelegt und alle Werte auf 0 bzw <em>null</em> gesetzt.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span>[] myIntArray = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];
Person[] myPersonArray = <span class="kw">new</span> Person[<span class="dv">100</span>];

Datentyp varname = {wert1, wert2, ...}; <span class="co">// sowohl Anzahl Elemente als auch Werte definieren.</span>

<span class="dt">int</span>[] myIntArray = {<span class="dv">12</span>, <span class="dv">43</span>, <span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">56</span>};
<span class="bu">String</span>[] myStrings = {<span class="st">&quot;Hallo&quot;</span>, <span class="st">&quot;Welt&quot;</span>};</code></pre></div>
<p><strong>Achtung: Die Länge und der Datentyp einer Array-Variable sind zur Laufzeit des Programms nicht änderbar.</strong></p>
<p>Nachdem Sie eine Array-Variable deklariert und erzeugt haben, können Sie jeden einzelnen Wert ansprechen, indem Sie nach dem Arraynamen die gewünschte Position (ein ganzzahliger Index) in eckigen Klammern angeben:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span>[] myIntArray = {<span class="dv">12</span>, <span class="dv">43</span>, <span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">56</span>};
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &gt; myIntArray.<span class="fu">length</span>; i++)
	<span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Position: &quot;</span> + i + <span class="st">&quot;; Wert: &quot;</span> + myIntArray[i]);</code></pre></div>
<p>Wichtig ist, dass das erste Element des Arrays mit <strong>0</strong> indiziert ist. Die Array-Eigenschaft <em>length</em> gibt die Anzahl der Elemente (n) des Arrays an. Der <strong>maximale Positionsindex ist n-1</strong>, da das erste Element des Arrays mit 0 indiziert wird.</p>
<figure>
<img src="media/array.png" alt="Array-Deklaration und Zugriff über den Index" id="fig:fig_array1" /><figcaption>Array-Deklaration und Zugriff über den Index</figcaption>
</figure>
<p>Betrachten Sie nochmals die Parameterliste der <code>main</code>-Funktion. Was für ein Datentyp wird übergeben? Wozu kann der Parameter <code>String[] args</code> genutzt werden?</p>
<p>Werden Arrays mit Datentypen mit fester Breite <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> (<code>int, float, double, Time</code> etc.) angelegt, kann die Speicheradresse <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_{n}</annotation></semantics></math> des <em>n</em>-ten Elements von der Startadresse des Arrays <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mn>0</mn></msub><annotation encoding="application/x-tex">s_{0}</annotation></semantics></math> ausgehend berechnet werden: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>=</mo><msub><mi>s</mi><mn>0</mn></msub><mo>+</mo><mi>n</mi><mo>⋅</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">x_{n}= s_{0} + n \cdot b</annotation></semantics></math></p>
<p>In der C/C++ Programmierung spricht man von Speicher-Arithmetik.</p>
</section>
<section id="praktische-anwendung-von-arrays" class="level3">
<h3><span class="header-section-number">5.3.2</span> Praktische Anwendung von Arrays</h3>
<p>Die feste Anzahl von Speicherplätzen in einem Array erscheint auf dem ersten Blick ungünstig. Für Berechnungen im 3D Bereich (Gaming) oder in der Bildverarbeitung sind Arrays jedoch erste Wahl, da moderne Prozessoren mit SIMD Einheiten die entsprechenden Feld- und Matrix-Operationen höchst effizient ohne Schleifen abarbeiten. Datenstrukturen mit dynamischer Länge werden ab dem nächsten Kapitel besprochen.</p>
</section>
<section id="kopieren-vs.-aliasing" class="level3">
<h3><span class="header-section-number">5.3.3</span> Kopieren vs. Aliasing</h3>
<p>Beachten Sie, dass sich eine Array-Variable immer auf die Speicheradresse des GANZEN Arrays bezieht. Es handelt sich dabei um eine sogenannte <strong>Referenzvariable</strong>. Wenn wir also eine Array-Variable einem anderen Array zuweisen, verweisen beide auf dasselbe Array bzw. Speicheradresse:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span>[] a = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];
a[i] = <span class="dv">1234</span>;
<span class="dt">int</span>[] b = a;

<span class="co">//…</span>

b[i] = <span class="dv">5678</span>; <span class="co">//a[i] ist jetzt 5678!!</span></code></pre></div>
<p>Eine solche Zuweisung wird <strong>Aliasing</strong> genannt. Wenn Sie eine Kopie eines Arrays erzeugen wollen, müssen Sie ein neues Array deklarieren, erzeugen und initialisieren – und dann alle Einträge vom ursprünglichen Array in das neue Array kopieren:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> N = a.<span class="fu">length</span>;
<span class="dt">double</span>[] b = <span class="kw">new</span> <span class="dt">double</span>[N];

<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &gt; N; i++){
	b[i] = a[i];
}</code></pre></div>
</section>
<section id="array-boundaries" class="level3">
<h3><span class="header-section-number">5.3.4</span> Array Boundaries</h3>
<p>Java führt eine automatische Bereichsprüfung durch. Wenn Sie in einem Array mit 5 Elementen versuchen, mit dem Index Nr. 5 oder 6 zuzugreifen, wird das Programm mit einer <code>ArrayIndexOutOfBounds</code>-Exception abgebrochen.</p>
</section>
<section id="benutzer-eingabe-über-konsole-oder-gui" class="level3">
<h3><span class="header-section-number">5.3.5</span> Benutzer-Eingabe über Konsole oder GUI</h3>
<p>Die Wahl der Benutzer-Eingabe (und Ausgabe) werden wir nicht festlegen. Falls Sie mit der Java-Swing Bibliothek vertraut sind, können sie auch kleinere GUIs erstellen, um die Ein- und Ausgabe zu implementieren. Andernfalls verwenden Sie die Ein-und Ausgabe der Konsole.</p>
<p>Verwenden Sie dazu eine <code>InputReader</code> Klasse, so wie Sie es bereits erstellt haben (bzw. fragen Sie die Lehrperson).</p>
<p>Wir werden in den folgenden Aufgaben mit primitiven Arrays arbeiten (z.B. für int oder double Daten). In diesem Lernabschnitt erstellen wir <em>statische</em> Methoden, damit wir uns auf die Programmierung unserer Funktionen beschränken können (Funktionen, wie im mathematischen Sinn). Später werden wir Klassen-eigene Funktionen implementieren.</p>
<p><strong>Hinweis:</strong> Die Java-Standardbibliotheken decken viele Funktionen ab, welche wir in diesem Modul behandeln (<code>Arrays</code>, <code>LinkedList</code>, Sortieren, etc.). Wir wollen aber zuerst diese Datenstrukturen und Algorithmen <em>selbst implementieren</em>, bevor wir auf vorgefertigte Klassen zurückgreifen.</p>
<pre class="include"><code>skript1c_ueb01_array_elementar.md</code></pre>
</section>
</section>
<section id="wdh_array" class="level2">
<h2><span class="header-section-number">5.4</span> Wiederholungsfragen</h2>
<ul>
<li>Auf welche Arten können Array-Variablen angelegt werden?</li>
<li>Welchen Index nutzen Sie, um auf das erste Element eines Arrays zuzugreifen?</li>
<li>Wie bestimmen Sie die Anzahl der Elemente einer Array-Variable?</li>
<li>Ihr Programm liefert eine <code>IndexOutOfBounds</code> Exception. Was ist passiert?</li>
<li>Was versteht man unter Aliasing?</li>
</ul>
<p><a href="#TOC">Zurück zum Inhaltsverzeichnis</a></p>
</section>
</section>
<section id="elementare-algorithmen-und-laufzeit-analysen" class="level1">
<h1><span class="header-section-number">6</span> Elementare Algorithmen und Laufzeit-Analysen</h1>
<p><strong>Lernziele:</strong></p>
<ul>
<li>Sie kennen grundlegende Sortier-Algorithmen</li>
<li>Sie visualisieren Algorithmen mit Struktogrammen oder PAP</li>
<li>Sie kennen die Grundelemente von Algorithmen und deren Umsetzung in einer Programmiersprache.</li>
<li>Sie implementieren einen Sortier-Algorithmus</li>
<li>Sie kennen Laufzeit-Komplexitätsklassen von Algorithmen</li>
<li>Sie schätzen die Laufzeit-Komplexität eines Algorithmus ab.</li>
</ul>
<section id="der-bubble-sort-algorithmus" class="level2">
<h2><span class="header-section-number">6.1</span> Der Bubble-Sort Algorithmus</h2>
<p>Das Sortieren gehört zu den Standard-Abläufen in der Informatik und reicht von simplen Datensätzen zu grossen Datenvolumen. Es gibt sehr viele Sortier-Algorithmen. Den Klassiker <em>BubbleSort</em> werden wir hier näher betrachten:</p>
<figure>
<img src="media/pap_bsort.png" alt="Quelle: http://www.tinohempel.de/info/info/ti/bubblesort.htm" id="fig:fig_strukto_bsort" /><figcaption>Quelle: <a href="http://www.tinohempel.de/info/info/ti/bubblesort.htm"><em>http://www.tinohempel.de/info/info/ti/bubblesort.htm</em></a></figcaption>
</figure>
<p>In jedem Durchgang wird das Feld (bzw. Array) von links nach rechts durchlaufen. Dabei wird in jedem Schritt das aktuelle Element <code>feld[j]</code> mit dem rechten Nachbarn <code>feld[j+1]</code> verglichen. Bei <em>aufsteigender</em> Sortierung werden die beiden Werte getauscht, wenn <code>feld[j] &gt; feld[j+1]</code>. Am Ende des ersten Durchganges steht garantiert das grösste Element am Ende der Liste, am Ende des zweiten Durchgangs das zweitgrösste an vorletzter Stelle usw.</p>
<p>Die Durchgänge werden solange wiederholt, bis die Eingabeliste vollständig sortiert ist. Dabei muss das letzte Element des vorherigen Durchlaufs nicht mehr betrachtet werden, da die restliche zu sortierende Eingabe keine größeren bzw. kleineren Elemente mehr enthält. Die Elemente bewegen sich also wie Blasen (engl. <em>Bubbles</em>) in einem Wasserglass nach oben (bzw. hinten), bis alle Blasen ihren Platz gefunden haben.</p>
<section id="bubble-sort-manuell-durchspielen" class="level3">
<h3><span class="header-section-number">6.1.1</span> Bubble-Sort manuell durchspielen</h3>
<p>Bevor wir den Algorithmus in Code umsetzen, werden wir diesen Algorithmus manuell durchspielen. Dazu brauchen Sie Papierschnipsel mit den unten stehenden Zahlen:</p>
<table border="1">
<tr>
<th>
51
</th>
<th>
13
</th>
<th>
9
</th>
<th>
44
</th>
<th>
18
</th>
<th>
93
</th>
<th>
25
</th>
</tr>
</table>
<p>Schreiben Sie diese Zahlen auf Notizpapier auf und zerschneiden Sie es. Dann ordnen Sie die Zahlenschnipsel wie oben angegeben an. Sortieren Sie nun die Schnipsel mit dem Bubble-Sort-Algorithmus und schreiben Sie die Ergebnisse aller Durchgänge auf. Wie viele Tauschvorgänge und Durchgänge werden benötigt?</p>
<table width="100%" border="1">
<tr>
<td>
 
</td>
</tr>
<tr>
<td>
 
</td>
</tr>
<tr>
<td>
 
</td>
</tr>
<tr>
<td>
 
</td>
</tr>
<tr>
<td>
 
</td>
</tr>
<tr>
<td>
 
</td>
</tr>
<tr>
<td>
 
</td>
</tr>
<tr>
<td>
 
</td>
</tr>
</table>
<p>Wie Sie vermutlich gemerkt haben, genügen <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> Durchgänge. Mit jedem Durchgang landet mindestens eine der Zahlen an seinem definitiven Platz. Tatsächlich genügen sogar <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math> Durchgänge, weil die letzte Zahl keinen Nachbarn mehr hat, mit dem sie vertauscht werden könnte.</p>
</section>
</section>
<section id="laufzeitanalyse" class="level2">
<h2><span class="header-section-number">6.2</span> Laufzeitanalyse</h2>
<section id="anzahl-vergleichsoperationen" class="level3">
<h3><span class="header-section-number">6.2.1</span> Anzahl Vergleichsoperationen</h3>
<p>In einer Liste mit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> Zahlen existieren <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math> Paare von benachbarten Zahlen, die bei einem Durchgang verglichen werden müssen. Und wir haben höchstens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> Durchgänge. Somit sind maximal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>⋅</mo><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">n \cdot (n-1)</annotation></semantics></math> Vergleichsoperationen nötig. Ausmultipliziert ergibt das <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n^2-n</annotation></semantics></math> Vergleichsoperationen. Da <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mn>2</mn></msup><annotation encoding="application/x-tex">n^2</annotation></semantics></math> schneller wächst als <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> können wir sagen, dass es ungefähr <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mn>2</mn></msup><annotation encoding="application/x-tex">n^2</annotation></semantics></math> Vergleichsoperationen für eine Liste mit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> Elementen gibt. Man spricht hier von <strong>quadratischer Komplexität</strong>.</p>
</section>
<section id="aufwand-im-besten-und-im-schlechtesten-fall" class="level3">
<h3><span class="header-section-number">6.2.2</span> Aufwand im besten und im schlechtesten Fall</h3>
<p>Wenn die Liste bereits sortiert ist, vergleicht der Algorithmus alle <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math> benachbarten Zahlenpaare einmal und stellt fest, dass es nichts zu tun gibt. Damit ist er fertig und es werden keine Zahlen vertauscht. Das ist der beste und schnellste Fall und benötigt <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math> Vergleiche und 0 Vertauschungen. Hier ist die Laufzeitkomplexität <em>linear</em>.</p>
<p>Im schlechtesten Fall ist die Liste genau andersherum sortiert, wie gewünscht. Dann müssen genau <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>⋅</mo><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">n \cdot (n-1)</annotation></semantics></math> Tauschoperationen und Vergleiche durchgeführt werden. Da der Aufwand einer Tauschoperation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math> beträgt, erhalten wir folgende Komplexität: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>⋅</mo><mi>n</mi><mo>⋅</mo><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>3</mn><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mn>3</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">3 \cdot n \cdot (n-1) = 3n^2 - 3n</annotation></semantics></math>. Konstanten können bei der Schätzung der Laufzeitanalyse weggelassen werden. Betrachtet wird immer nur der Summand mit dem grössten Exponenten. Also ist die Laufzeitkomplexitätsklasse im schlechtesten Fall ebenfalls <em>quadratisch</em>.</p>
<pre class="include"><code>skript1d_ueb01_bsort_laufzeit.md</code></pre>
</section>
<section id="komplexitätsklassen-von-algorithmen" class="level3">
<h3><span class="header-section-number">6.2.3</span> Komplexitätsklassen von Algorithmen</h3>
<p>Die Berechenbarkeit eines Algorithmus ist ein sehr wichtiges Kriterium für dessen Eignung in der Programmierung. Stellen Sie sich vor, Sie haben einen dreifach verschachtelten Algorithmus zur Problemlösung in einer kurzen Datenstruktur gefunden. Was nützt dieser Algorithmus, wenn er das gleiche Problem mit einer sehr langen Datenstruktur erst in mehreren hundert Jahren lösen kann?</p>
<p>Vereinfacht kann die Rechenzeit eines Algorithmus wie folgt berechnet werden:</p>
<p>Man multipliziert die Anzahl der Rechenschritte der inneren Schleife mit dem Rechenaufwand des Schleifenkopfes, und multipliziert diesen Wert mit dem Rechenaufwand der umschliessenden Schleife.</p>
<p>Was für die Komplexität der Rechenzeit zutrifft, gilt auch für die Speicherkomplexität. Je mehr Variablen in den inneren Schleifen zwischengespeichert werden, desto mehr Arbeitsspeicher wird der Algorithmus zur Laufzeit benötigen.</p>
<p>Die folgende Tabelle illustriert die wichtigsten Komplexitätsklassen von Algorithmen.</p>
<table>
<thead>
<tr class="header">
<th><strong>f(n)</strong></th>
<th></th>
<th><strong>f(10)</strong></th>
<th><strong>f(100)</strong></th>
<th><strong>f(1000)</strong></th>
<th><strong>f(10000)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>konstant</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>log<sub>2</sub>(n)</td>
<td>logarithmisch</td>
<td>3</td>
<td>7</td>
<td>10</td>
<td>13</td>
</tr>
<tr class="odd">
<td>n</td>
<td>linear</td>
<td>10</td>
<td>100</td>
<td>1000</td>
<td>10<sup>4</sup></td>
</tr>
<tr class="even">
<td>n * log<sub>2</sub>(n)</td>
<td></td>
<td>30</td>
<td>700</td>
<td>10<sup>4</sup></td>
<td>13 * 10<sup>4</sup></td>
</tr>
<tr class="odd">
<td>n<sup>2</sup></td>
<td>quadratisch</td>
<td>100</td>
<td>10<sup>4</sup></td>
<td>10<sup>6</sup></td>
<td>10<sup>8</sup></td>
</tr>
<tr class="even">
<td>n<sup>3</sup></td>
<td>kubisch</td>
<td>1000</td>
<td>10<sup>6</sup></td>
<td>10<sup>9</sup></td>
<td>10<sup>12</sup></td>
</tr>
<tr class="odd">
<td>2<sup>n</sup></td>
<td>exponentiell</td>
<td>1000</td>
<td>10<sup>30</sup></td>
<td>10<sup>300</sup></td>
<td>10<sup>3000</sup></td>
</tr>
</tbody>
</table>
<ul>
<li>Komplexitätsklassen und Beispiele, nach M.Wirsing; LMU München 2008 *</li>
</ul>
<pre class="include"><code>skript1d_ueb02_laufzeitanalyse.md
skript1d_ueb03_bsort_strings.md
skript1d_ueb04_adv_qsort.md</code></pre>
</section>
</section>
<section id="wdh_funkomplex" class="level2">
<h2><span class="header-section-number">6.3</span> Wiederholungsfragen</h2>
<ul>
<li>Wie funktioniert der BubbleSort-Algorithmus?</li>
<li>Welche Laufzeit-Komplexitätsklassen gibt es? Sortieren Sie diese nach Performance absteigend.</li>
<li>Wie bestimmen Sie die Laufzeit einer Methode?</li>
</ul>
<p><a href="#TOC">Zurück zum Inhaltsverzeichnis</a></p>
</section>
</section>
<section id="dynamische-datenstrukturen-verkettete-liste" class="level1">
<h1><span class="header-section-number">7</span> Dynamische Datenstrukturen: Verkettete Liste</h1>
<section id="lernziele_vk" class="level2">
<h2><span class="header-section-number">7.1</span> Lernziele</h2>
<ul>
<li>Kennen des Unterschieds zwischen Wertevariablen und Referenzvariablen / Zeigervariablen.</li>
<li>Kennen von Sprachmitteln einer Programmiersprache für das Deklarieren und das Arbeiten mit Werte- und Referenzvariablen.</li>
<li>Beschreiben des Konzepts und den Nutzen von verketteten Datenstrukturen.</li>
<li>Zeichen einer Notation für die Darstellung von verketteten Datenstrukturen.</li>
<li>Implementieren einer einfach verketteten Liste</li>
<li>Sortieren einfach verketteter Listen</li>
</ul>
</section>
<section id="eine-elementare-datenstruktur-verkettete-liste" class="level2">
<h2><span class="header-section-number">7.2</span> Eine elementare Datenstruktur: Verkettete Liste</h2>
<p>Objekt-Arrays sind denkbar ungeeignet, wenn wir dynamische Datenmengen (veränderliche Anzahl von Objekten) verwalten wüssen.</p>
<p>Als schlaue Alternative kommt eine weitere elementare Datenstruktur zur Anwendung, welche ihre Grösse schnell und unkompliziert verändern kann (was wir bei einem Array nicht können):</p>
<p>Die Verkettete Liste (Abk. <strong>VK</strong>, engl. <em>LinkedList</em>) kann mit dynamischen Datenmengen umgehen. Ein weiterer Vorteil ist, dass sie eine höhere Flexibilität ermöglicht, indem die Elemente in effizienter Weise umgeordnet werden können. Dafür ist ein schneller Zugriff auf ein Element über den Positionsindex nicht möglich. Das erklärt sich aus der internen Struktur der verketteten Liste:</p>
<p>Jedes Element der einfach verketteten Liste enthält neben dem eigentlichen Wert die Speicheradresse des nächsten Listenelements. Die Speicheradresse nennt man in der C/C++ Welt auch Zeiger. Der <em>Zeiger</em> ist damit die Verknüpfung oder das Bindeglied innerhalb der Liste, durch den jedes Element das nächste Element kennt.</p>
<p>Ein Element ist somit ein Knoten (<em>Node</em>), welcher durch Verkettung bzw. Verknüpfung auf den nächsten Knoten verweist (<em>next</em>).</p>
<p>Der Zugriff auf eine VK erfolgt grundsätzlich vom ersten Element der Liste (<em>head</em>). Daraus folgt, dass eine VK immer von Anfang an durchschritten werden muss, bis das gewünschte Element an einer bestimmten Position geliefert werden kann.</p>
<figure>
<img src="media/vk.png" alt="Notation einfach verkettete Liste, Quelle: CrunchifyCode" id="fig:fig_notation_vk" /><figcaption>Notation einfach verkettete Liste, Quelle: CrunchifyCode</figcaption>
</figure>
<p>Neben der einfach verketteten Liste gibt es auch doppelt verkettete Listen. Die Nodes der doppelt verketteten Liste enthalten neben der Zeigeradresse des Nachfolgeelements auch eine Zeigeradresse auf das Vorgängerelement.</p>
<section id="implementierung" class="level3">
<h3><span class="header-section-number">7.2.1</span> Implementierung</h3>
<p>In einer objektorientierten Sprache ist die Implementierung von verketteten Listen nicht sehr schwierig.</p>
<p><strong>Die Node-Klasse</strong></p>
<p>Wir beginnen mit dem Node-Object als innere Klasse, welche die Knotenabstraktion definiert:</p>
<pre><code>private class Node{
	Item item;
	Node next;
}</code></pre>
<p>Ein <code>Node</code>-Objekt besitzt zwei Instanzvariablen: eine vom abstrakten Typ <code>Item</code> (ein parametrisierter Typ, den Sie selber bestimmen können) und eine weitere Instanzvariable vom Typ <code>Node</code> selbst. Eine Datenstruktur, die sich selbst als Variable enthält, nennt man rekursive Datenstruktur.</p>
<p>Wir definieren <code>Node</code> direkt innerhalb der Klasse, in der wir sie verwenden wollen, und zwar als <em>private</em>, da Clients keinen Zugriff darauf erhalten sollen.</p>
<p><strong>Beispiel für die innere Klasse:</strong></p>
<pre><code>private class Node{
	//these are private
	private Object item;
	private Node next;
	
	//constructor
	public Node (Object value){
		next = null;
		item = value;
	}
	
	//another constructor
	public Node(Object value, Node nextValue){
		next = nextValue;
		item = value;
	}
}</code></pre>
<p>Die Instanzvariable <code>item</code> wird in unserem Beispiel als <code>Object</code> Datentyp deklariert und kann damit alle von Object abgeleiteten Datentypen aufnehmen (also <code>Integer, Double, String</code>,...).</p>
<p>Der Basis-Konstruktor setzt das nächste Element auf <em>null</em>, weil es nur das aktuelle Element initialisiert. Die Klasse <code>Node</code> hat natürlich auch <code>set</code>- und <code>get</code>-Methoden, um auf die Daten zugreifen zu können. <code>Node</code> benötigt keine weiteren Methoden, da es sich um eine reine Datenstruktur handelt.</p>
</section>
</section>
<section id="die-mylinkedlist---klasse" class="level2">
<h2><span class="header-section-number">7.3</span> Die MyLinkedList - Klasse</h2>
<p>Ausserhalb der inneren Klasse implementieren wir die eigentliche Klasse <code>MyLinkedList</code>, in welcher die Node-Objekte verkettet werden:</p>
<pre><code>public class MyLinkedList {
	private Node head; //reference to the head node
	private int listCount; //counter used for looping

	//constructor
	public MyLinkedList(){
		//when initialised it&#39;s an empty list, so the reference to the
		//head node is set to a new node with no data:
		head = new Node(null);
		listCount = 0;
	}
…
}</code></pre>
<p>Ganz wichtig ist, dass im Konstruktor eine Liste mit einem Element erstellt wird. Wir verwenden dabei das vorderste Element (<code>head</code>). Das vorderste Element hat noch keinen Verweis auf ein nächstes, deshalb setzen wir den Knoten <code>next</code> auf null.</p>
<section id="elemente-hinzufügen" class="level3">
<h3><span class="header-section-number">7.3.1</span> Elemente hinzufügen:</h3>
<p>Prinzip: ein neues Element wird ans Ende der Liste gestellt. Also muss jeweils von <code>head</code> ausgehend zunächst das Ende der Liste gesucht werden.</p>
<p>Innerhalb der MyLinkedListKlasse:</p>
<pre><code>public void append(Object value){
	Node newElement = new Node(value);
	Node current = this.head; //set current to head (start) of the list
	//make sure to add at the end of the list, loop through the elements:
	while (current.getNext() != null){
		current = current.getNext();
	}
	//add the new element to the end of the list:
	current.setNext(newElement);
	
	//increment list counter:
	listCount++;
}</code></pre>
<p>Wichtig sind die letzten 4 Zeilen. Das aktuelle Element <code>current</code> (dh. das letzte) zeigt neu auf ein weiteres Element. Das wird somit zum neuen letzten Element. Zudem muss der Listen-interne Zähler inkrementiert werden.</p>
<pre class="include"><code>skript2a_ueb01_vk.md</code></pre>
</section>
</section>
<section id="verkettete-liste-vs.-array" class="level2">
<h2><span class="header-section-number">7.4</span> Verkettete Liste vs. Array</h2>
<p>Ein grosser Vorteil der verketteten Liste ist die dynamische Grösse. Die Anzahl Elemente muss nicht fix definiert sein. Anderseits ist der Zugriff in einer verketteten Liste viel mühsamer als in einem Array. In einem Array können wir jederzeit via Index direkt auf ein Element zugreifen. In der verketteten Liste müssen wir die Liste jeweils bis zum gewünschten Element durchschreiten.</p>
<pre class="include"><code>skript2a_ueb02_adv_vk.md</code></pre>
</section>
<section id="wdh_vk" class="level2">
<h2><span class="header-section-number">7.5</span> Wiederholungsfragen</h2>
<ul>
<li>Welche Daten können in verketteten Listen gespeichert werden?</li>
<li>Welche Vor- und Nachteile ergeben sich beim Einsatz von verketteten Listen bzw. Arrays?</li>
<li>Beschreiben Sie Ihrem Nachbarn den Aufbau einer verketteten Liste.</li>
<li>Was ist zu beachten, wenn Sie ein Element aus einer verketteten Liste entfernen?</li>
<li>Vergleichen Sie die Laufzeit des BubbleSort-Algorithmus für Arrays und verkettete Listen.</li>
</ul>
<p><a href="#TOC">Zurück zum Inhaltsverzeichnis</a></p>
</section>
</section>
<section id="dynamische-datenstrukturen-ii-stacks-und-queues" class="level1">
<h1><span class="header-section-number">8</span> Dynamische Datenstrukturen II: Stacks und Queues</h1>
<section id="lernziele_stacks_queues" class="level2">
<h2><span class="header-section-number">8.1</span> Lernziele</h2>
<ul>
<li>Beschreiben Eigenschaften der Datenstruktur Stack (Stapel) und Queue</li>
<li>Einsetzen Datenstrukturen Stack und Queue</li>
<li>Implementieren und Anwenden Interface <code>Iterator</code></li>
</ul>
</section>
<section id="die-verkettete-liste-als-stapel-speicher" class="level2">
<h2><span class="header-section-number">8.2</span> Die verkettete Liste als Stapel-Speicher</h2>
<p>Mit Hilfe der <em>verketteten Liste</em>, können wir eine weitere häufig benützte Datenstruktur mit speziellen Eigenschaften umsetzen: den Stapel, bzw. Stack.</p>
<p>Der Stack arbeitet nach dem LIFO-Prinzip (&quot;<strong>L</strong>ast <strong>I</strong>n – <strong>F</strong>irst <strong>O</strong>ut&quot;). Als Analogie können Sie sich den Stack wie einen Stapel Teller in der Mensa vorstellen:</p>
<figure>
<img src="media/teller.png" alt="Tellerstapel" id="fig:fig_teller" /><figcaption>Tellerstapel</figcaption>
</figure>
<figure>
<img src="media/stack_ops.png" alt="Stack-Prinzip" id="fig:fig_stack" /><figcaption>Stack-Prinzip</figcaption>
</figure>
<p>Die Grundoperationen für einen Stack sind:</p>
<ul>
<li><em>push</em> -&gt; ein Element zuoberst hinzufügen</li>
<li><em>pop</em> -&gt; das Element zuoberst entfernen</li>
</ul>
<p>Praktische Anwendung finden Stack-Datenstrukturen beispielsweise in <em>UNDO</em> Funktionen von Bild- und Dokumentbearbeitungsprogrammen. Weniger sichtbar, aber für die Arbeit am PC wichtig ist die Stack-Architektur des Speichers, den ein Programm während der Laufzeit benutzt. Jeder neue Methodenaufruf X bekommt einen Speicherbereich <em>oberhalb</em> der aufrufenden Funktion A, der nach Beendigung der Funktion X wieder freigegeben wird. Durch diese Architektur wird beispielsweise die Lebensdauer und vor allem die Sichtbarkeit der lokalen Variablen beeinflusst.</p>
<p>Die innere Datenstruktur der verketteten Liste (<code>class Node</code>) eignet sich sehr gut, um einen Stack umzusetzen. Wir schreiben somit eine <code>Stack</code>-Klasse, welche die Datenstruktur der verketteten Liste wieder verwendet:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> MyStack {
	<span class="co">//reference to the first element in stack (=last added element)</span>
	<span class="kw">private</span> <span class="bu">Node</span> first;
	<span class="co">//counter</span>
	<span class="kw">private</span> <span class="dt">int</span> listCount;

	<span class="co">//constructor</span>
	<span class="kw">public</span> <span class="fu">MyStack</span>(){
		listCount= <span class="dv">0</span>;
	}

	<span class="co">//TODO:add push and pop methods here</span>
}</code></pre></div>
<p>Wir fügen ein Element zuvorderst in die Kette, mit einer <code>push</code> Methode:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">//Adds element to the top of the list</span>
<span class="kw">public</span> <span class="dt">void</span> <span class="fu">push</span>(<span class="bu">Object</span> value){
	<span class="co">//the new element is the last in the list:</span>
	<span class="bu">Node</span> current = first;
	first = <span class="kw">new</span> <span class="bu">Node</span>(value);
	first.<span class="fu">setNext</span>(current);
	listCount++;
}</code></pre></div>
<p>Die Funktion <code>pop</code> entnimmt das oberste Element der Liste und gibt es zurück:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">//Removes top element from stack</span>
<span class="kw">public</span> <span class="bu">Object</span> <span class="fu">pop</span>(){
	<span class="bu">Object</span> value = first.<span class="fu">value</span>;
	first = first.<span class="fu">next</span>; <span class="co">//now next element is the first</span>
	listCount--;
	<span class="kw">return</span> value;
}</code></pre></div>
<p>Ein Aufruf in der main-Methode sieht somit wie folgt aus:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">MyStack list = <span class="kw">new</span> <span class="fu">MyStack</span>();
list.<span class="fu">push</span>(<span class="st">&quot;to&quot;</span>);
list.<span class="fu">push</span>(<span class="st">&quot;be&quot;</span>);
list.<span class="fu">push</span>(<span class="st">&quot;or&quot;</span>);
list.<span class="fu">push</span>(<span class="st">&quot;not&quot;</span>);</code></pre></div>
<pre class="include"><code>skript2b_ueb01_implementstack.md</code></pre>
</section>
<section id="die-verkettete-liste-als-warteschlange" class="level2">
<h2><span class="header-section-number">8.3</span> Die Verkettete Liste als Warteschlange</h2>
<p>Eine weitere wichtige Spezialform der Verketteten Liste ist die Warteschlange (engl. Queue). Wie an der Supermarkt-Kasse werden bei einer Queue neue Elemente hinten angehängt. Entfernt werden nur Elemente von vorne. Dabei spricht man vom FIFO (<strong>F</strong>irst-<strong>I</strong>n <strong>F</strong>irst-<strong>O</strong>ut), im Gegensatz zum LIFO bei der Stack-Datenstruktur.</p>
<p>Bedeutende praktische Anwendung für Queues sind beispielsweise Anzeigetafeln für Zugsabfahrten an Bahnhöfen oder Callcenter-Routingsysteme.</p>
</section>
<section id="verwendung-von-iterator-anstelle-von-for--oder-while-schleifen" class="level2">
<h2><span class="header-section-number">8.4</span> Verwendung von <code>Iterator</code> anstelle von <code>for</code>- oder <code>while</code>-Schleifen</h2>
<p>Anstatt der üblichen (und fehleranfälligen) <code>for</code>-Schleife zum Durchlaufen aller Elemente des Stacks bzw. der Verketteten Liste sollen nun Iteratoren eingesetzt werden.</p>
<p>Iteratoren erlauben dem Benutzer, nacheinander auf jedes Element einer Datenmenge zuzugreifen, unabhängig wie die dahinter liegende Datenstruktur implementiert ist. Der Iterator kümmert sich dabei hinter den Kulissen um die Grenzen der Datenstruktur.</p>
<p>Eine Iteratorklasse wird in enger Koordination mit ihrer Containerklasse, also ihrer Menge, entworfen. Üblicherweise stellt die Containerklasse die Funktionen zur Verfüg­ung, die zur Erstellung von Iteratoren benutzt werden.</p>
<p>Gewissermassen sind Iteratoren die Vorfahren der foreach-Schleife in Java, PHP &amp; Co.</p>
<p>Zum Implementieren des Iterators innerhalb der Verketteten Liste bzw. Stack verwenden wir die Interfaces (Schnittstelle) <code>Iterable</code> und <code>Iterator</code>. Damit wird die Wiederverwendbarkeit sichergestellt und die Einarbeitungszeit für andere Programmierer reduziert. Zum Verwenden der Schnittstellen schreiben wir das <strong>implements</strong> Schlüsselwort und die beiden Schnittstellennamen in der Klassendeklaration hinter den Klassennamen.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> MyStack <span class="kw">implements</span> <span class="bu">Iterable</span>&lt;<span class="bu">Object</span>&gt;, <span class="bu">Iterator</span>&lt;<span class="bu">Object</span>&gt; {

	<span class="co">//reference to the first element in stack (=last added element)</span>
	<span class="kw">private</span> <span class="bu">Node</span> first;
	<span class="kw">private</span> <span class="bu">Node</span> currentIterPos; <span class="co">//contains current position of iterator</span>

	<span class="co">//…</span>
}</code></pre></div>
<p><code>Iterable&lt;Object&gt;</code> und <code>Iterator&lt;Object&gt;</code> sind sogenannte generische Schnittstellen. D.h sie können auf verschieden Datentypen innerhalb der implementierenden Datenstruktur angewandt werden. Für eine Liste mit Elementen der Klasse <code>Person</code> spezialisieren Sie die Schnittstelle entsprechend: <code>public class MyStack implements Iterable&lt;Person&gt;, Iterator&lt;Person&gt; {...}</code>.</p>
<p>Für die Generischen Schnittstellen in unserer Datenstruktur benutzen wir also den gleichen Datentyp wie in der Node-Klasse enthalten. Zusätzlich benötigen wir eine neue <code>Stack</code>-Instanzvariable zur Verwaltung der aktuellen Listenpostion: <code>currentIterPos</code>. <code>currentIterPos</code> ist vom Datentyp <code>Node</code>.</p>
<p>Das Interface <code>Iterable</code> verlangt, dass wir die Methode <code>public Iterator&lt;Object&gt; iterator()</code> innerhalb der Klasse MyStack implementieren. Nichts einfacher als das:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="bu">Iterator</span>&lt;<span class="bu">Object</span>&gt; <span class="fu">iterator</span>(){

	<span class="kw">this</span>.<span class="fu">currentIterPos</span> = <span class="kw">this</span>.<span class="fu">head</span>; <span class="co">//set current position=top of stack</span>
	<span class="kw">return</span> <span class="kw">this</span>;
}</code></pre></div>
<p>Das Interface <code>Iterator</code> verlangt zwingend, dass folgende Methoden implementiert sind:</p>
<ul>
<li><code>hasNext()</code> -&gt; gibt true oder false zurück</li>
<li><code>next()</code> -&gt; gibt das nächste Element zurück</li>
<li><code>remove()</code> -&gt; entfernt ein Element</li>
</ul>
<p>Die Methode <code>remove()</code> lassen wir leer, weil wir es vermeiden wollen, Elemente aus einer Liste zu entfernen, wenn wir gleichzeitig auch noch iterieren.</p>
<p>Uns interessiert vor allem <code>hasNext()</code> und <code>next()</code>. Für <code>hasNext()</code> prüfen wir, ob das aktuelle Element noch einen Nachfolger hat. Das sieht dann wie folgt aus:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="at">@Override</span>
<span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">hasNext</span>() {
	<span class="kw">return</span> <span class="kw">this</span>.<span class="fu">currentIterPos</span>.<span class="fu">next</span> != <span class="kw">null</span>; <span class="co">// return false if null</span>
}</code></pre></div>
<pre class="include"><code>skript2b_ueb02_iteratoren.md</code></pre>
</section>
<section id="wdh_stack_queue" class="level2">
<h2><span class="header-section-number">8.5</span> Wiederholungsfragen</h2>
<ul>
<li>Was ist der Unterschied zwischen einer <em>Queue</em> und einer <em>Stack</em>-Datenstruktur?</li>
<li>Wie können Sie Ihre Verkettete Liste optimieren, damit die <code>Queue</code>-Funktionen <code>push</code> und <code>pop</code> performant arbeiten?</li>
<li>Was müssen Sie tun, wenn Sie in einer Klasse eine Schnittstelle implementieren?</li>
<li>Wozu dient die <code>Iterator</code>-Schnittstelle?</li>
</ul>
<p><a href="#TOC">Zurück zum Inhaltsverzeichnis</a></p>
</section>
</section>
<section id="dynamische-datenstrukturen-iii-java-collections" class="level1">
<h1><span class="header-section-number">9</span> Dynamische Datenstrukturen III: Java Collections</h1>
<section id="lernziele_javacollections" class="level2">
<h2><span class="header-section-number">9.1</span> Lernziele</h2>
<ul>
<li>Kennen den Aufbau der Java Collections</li>
<li>Erklären am Beispiel des Collection Interfaces die Bedeutung von Schnittstellen</li>
<li>Erklären die Bedeutung von generischen Klassen und Schnittstellen</li>
<li>Nutzen wichtige Datenstrukturen der Java Collection-Library</li>
<li>Anwenden Lambda-Funktionen für Suche und Sortieren innerhalb einer Collection</li>
</ul>
</section>
<section id="datenstrukturen-in-java-die-collections-bibliothek" class="level2">
<h2><span class="header-section-number">9.2</span> Datenstrukturen in Java: Die Collections-Bibliothek</h2>
<p>Das Package <code>java.util</code> stellt häufig genutzte Datenstrukturen wie Listen, Stacks und Queues mit wichtigen Funktionen bereit. Durch den Einsatz dieser Klassen können sich Entwickler viel Zeit zum Erstellen und Testen solcher Datenstrukturen sparen und sich auf die eigentliche Problemlösung konzentrieren.</p>
</section>
<section id="die-schnittstellen-collection-und-list" class="level2">
<h2><span class="header-section-number">9.3</span> Die Schnittstellen Collection und List</h2>
<p>Die Datenstrukturen aus <code>java.util</code> nutzen die gemeinsame Schnittstelle <code>Collection</code>. Diese Schnittstelle definiert allgemeine Methoden und Funktionen, die innerhalb der Klassen implementiert sind. Eine Schnittstelle selbst beinhaltet allerdings keinen Code. Schnittstelle heisst auf Englisch interface. Beide Begriffe werden hier synonym gebraucht.</p>
<figure>
<img src="media/java_util_collection.png" alt="Quelle: http://www.beingjavaguys.com/2013/03/java-collection-framework.html" id="fig:fig_collectionframework" /><figcaption>Quelle: http://www.beingjavaguys.com/2013/03/java-collection-framework.html</figcaption>
</figure>
<p>Bei der Benutzung einer Klasse, die diese Schnittstelle imple­mentiert, wissen Entwickler, welche Funktionen vorhanden sind. Dies dient der schnelleren und stabileren Software-Entwicklung.</p>
<p>Beispiele für Methoden des <code>Collection</code>-Interfaces sind:</p>
<ul>
<li><code>add(Object o)</code></li>
<li><code>remove(Object o)</code></li>
<li><code>iterator()</code></li>
<li><code>size()</code></li>
<li><code>stream()</code></li>
<li><code>toArray()</code></li>
</ul>
<p>Das <code>List</code>-Interface definiert zusätzliche Methoden, um über Index-Adressen auf Listenelemente zuzugreifen:</p>
<ul>
<li><code>remove(int pos)</code></li>
<li><code>add(&lt;T&gt; object, int pos)</code></li>
</ul>
<p>Mit dem ebenfalls definierten <code>ListIterator</code> können die Datenstrukturen vorwärts <em>und</em> rückwärts durchschritten werden.</p>
</section>
<section id="implementierung-der-schnittstellen-in-klassen-des-java.util-pakets" class="level2">
<h2><span class="header-section-number">9.4</span> Implementierung der Schnittstellen in Klassen des <code>java.util</code> Pakets</h2>
<p>Die bisher behandelten Datenstrukturen sind in Java auch in der Collections-Bibliothek enthalten:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>verwendete Datenstruktur</strong></th>
<th style="text-align: left;"><strong>In Collections-Bibliothek</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">primitiver Array</td>
<td style="text-align: left;"><code>ArrayList*</code> oder <code>Arrays</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Verkettete Liste</td>
<td style="text-align: left;"><code>LinkedList*</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Eigener Stack / Stapel</td>
<td style="text-align: left;"><code>Stack**</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">noch nicht behandelt</td>
<td style="text-align: left;"><code>Map</code></td>
</tr>
</tbody>
</table>
<p><code>*</code> beide Klassen implementieren das Interface <code>List</code></p>
<p><code>**</code> Wie in Abbildung 1 sichtbar, ist der <code>Stack</code> eine Erweiterung der<br />
<code>Vector</code> Klasse. Der <code>Vector</code> wiederum ist eine spezielle Form eines<br />
Arrays. Wie bei <code>ArrayList</code> ist ein <code>Vector</code> dynamisch erweiterbar, hat<br />
aber den Vorteil, dass es <strong>synchronized</strong> ist (d.h. er kann nicht gleichzeitig von mehreren Prozess geändert werden).</p>
<p>Die Verwendung des Interfaces <code>Collection</code> ermöglicht die Definition des <em>inneren</em> Datentyps schon bei der Instantiierung eines Collection-Objekts:</p>
<p><code>List&lt;String&gt; myStrings = new ArrayList&lt;String&gt;();</code></p>
<p><code>Stack&lt;Card&gt; deck42 = new Stack&lt;Card&gt;();</code></p>
<p>Solche Klassen und Schnittstellen werden in Java <em>generisch</em> bezeichnet. In C++ wird der Begriff Template-Klasse genutzt.</p>
</section>
</section>
<section id="anwendungsgebiete-von-arraylist-vector-und-linkedlist" class="level1">
<h1><span class="header-section-number">10</span> Anwendungsgebiete von <code>ArrayList</code>, <code>Vector</code> und <code>LinkedList</code></h1>
<p>Die Klassen <code>ArrayList</code>, <code>Vector</code> und <code>LinkedList</code> stellen dynamische Datenstrukturen dar. Die Anzahl der darin gespeicherten Elemente darf sich also zur Laufzeit des Programms ändern. Da alle diese Klassen das <code>List</code>-Interface implementieren, stehen (unter anderem) folgende Methoden zur Verfügung:</p>
<ul>
<li><code>add(int index, Element e)</code></li>
<li><code>remove(Element e)</code></li>
<li><code>remove(int index)</code></li>
<li><code>get(int index)</code></li>
</ul>
<p>Äusserlich betrachtet erfüllen diese Funktionen das Gleiche in allen drei Klassen. Laufzeit-technisch bestehen jedoch Unterschiede:</p>
<ul>
<li><code>ArrayList</code> und <code>Vector</code> sind intern als Array implementiert. Zugriffe auf die einzelnen Elemente sind also sehr schnell und unabhängig von der Anzahl der enthaltenen Elemente. Jedoch sind Operationen wie das Hinzufügen oder Entfernen von Elementen rechenintensiv, da das gesamte Feld neu strukturiert werden muss. Der Vorteil bei der Benutzung der <code>Vector</code>-Klasse liegt insbesondere in der Absicherung für gleichzeitige Zugriffe bei paralleler Programmierung.</li>
<li>Die Klasse <code>LinkedList</code> ist intern als verkettete Liste implementiert und unterstützt das Durchschreiten von vorne nach hinten. Die Zugriffszeit auf einzelne Elemente ist abhängig von der Position und steigt linear mit der Anzahl der Elemente. Das Gleiche trifft auf Einfüge- und Löschoperationen zu.</li>
</ul>
<p>Die folgende Abbildung illustriert die Laufzeitabhängigkeiten:</p>
<figure>
<img src="media/arraylist-vs-linkedlist1.png" alt="Laufzeitverhalten von LinkedList und ArrayList, Quelle: www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/" id="fig:fig_laufzeit" /><figcaption>Laufzeitverhalten von LinkedList und ArrayList, Quelle: <a href="http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/">www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/</a></figcaption>
</figure>
<p><strong>Zusammenfassung</strong>: Setzen Sie <code>ArrayList</code> oder <code>Vector</code> ein, wenn Sie sehr schnelle Lesezugriffe benötigen und relativ wenige Einfüge- und Löschoperationen zu erwarten sind. Andernfalls ist die <code>LinkedList</code> ein guter Kandidat.</p>
<p>Weitere Informationen finden Sie hier: <a href="http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/">www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/</a></p>
<section id="die-foreach-schleife-mit-collections" class="level2">
<h2><span class="header-section-number">10.1</span> Die <code>foreach</code>-Schleife mit Collections</h2>
<p>Eine grundlegende Operation auf Collections ist die Verwendung von <code>foreach</code> zum Durchlaufen und Bearbeiten aller Elemente in einer Collection. Im Gegensatz zum klassischen <code>for</code> müssen Sie hier keine <code>int</code>-Schleifenvariable hochzählen und am Ende abbrechen. Das jeweilige Listenelement steht Ihnen direkt zur Verfügung (im Beispiel <code>String s</code>). Das führt zu sehr kompaktem Code, wie in diesem Beispiel für einen Stack:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="bu">Stack</span>&lt;<span class="bu">String</span>&gt; collection = <span class="kw">new</span> <span class="bu">Stack</span>&lt;<span class="bu">String</span>&gt;();
...
<span class="kw">for</span> (<span class="bu">String</span> s: collection){
	<span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Element = &quot;</span> + s);
}</code></pre></div>
<p>Welche andere <code>for</code>-Schleife könnte man für die gleiche Operation verwenden? Notieren Sie diese andere <code>for</code>-Schleife (diese sollten sie jetzt ziemlich gut kennen)</p>
<p>Beide Schleifen (<code>foreach</code> und das normale <code>for</code>) sind eine Kurzform für ein <code>while</code>-Konstrukt. Wenn man das Interface <code>Iterator</code> verwendet, kann man eine sehr elegante while-Schleife verwenden. Wir haben das schon bei der Erweiterung unseres Stacks angetroffen:</p>
<p>Der <code>Iterator</code> selbst ist ein Interface. Sobald eine Klasse dieses Interface implementiert, hat es automatisch das Verhalten eines Iterators. Siehe dazu die JavaDoc-Hilfe unter <code>java.util.Iterator</code>.</p>
</section>
<section id="lambda-funktionen" class="level2">
<h2><span class="header-section-number">10.2</span> Lambda-Funktionen</h2>
<p>Wie haben vorher einige Sortierfunktionen selbst erstellt. <code>java.utils</code> stellt auch hier hocheffiziente fertige Funktionen zur Verfügung, welche die Programmierer nur noch parametrisieren müssen. Dies geschieht mit sogenannten <em>Lambda-Funktionen</em>. Lambda-Funktionen stammen aus der Welt der funktionalen Programmierung (z.B. aus der Sprache <em>LISP</em>). Sie wurden mit Java SE8 zur Sprachspezifikation hinzugefügt und ermöglichen sehr elegante Sortier- und Suchfunktionen. Wir wollen hier zwei Beispiele genauer ansehen.</p>
<section id="sortieren-von-arraylist-und-linkedlist" class="level3">
<h3><span class="header-section-number">10.2.1</span> Sortieren von <code>ArrayList</code> und <code>LinkedList</code></h3>
<p>In der Praxis werden Listen häufig nach bestimmten Kriterien sortiert. Mit der Klassenfunktion <code>sort(..)</code> stellen Klassen des <code>List</code>-Interfaces ein leistungsfähiges Werkzeug dazu bereit. <code>sort(..)</code> bekommt als Parameter eine sogenannte Lambda-Funktion übergeben.</p>
<p>Gegeben ist folgendes Szenario: Die Klasse <code>Person</code> enthält die Attribute <code>familyName, firstName, city</code> und <code>birthDate</code> als Strings. In der ArrayList <code>kundenverwaltung</code> sind alle Kunden der Topomedics AG instantiiert. Nun kann die Liste mit der <code>sort()</code> Funktion beispielsweise nach <code>familyName</code> sortiert werden:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// loading all data from file into list...</span>
<span class="bu">ArrayList</span>&lt;Person&gt; kundenverwaltung = <span class="fu">loadAllData</span>();

<span class="co">// in-place sort by familyName</span>
kundenverwaltung.<span class="fu">sort</span>( (p1,p2) -&gt; p1.<span class="fu">familyName</span>.<span class="fu">compareTo</span>(p2.<span class="fu">familyName</span>));</code></pre></div>
<p>Die Funktion <code>void sort(..)</code> hat einen Lambda-Ausdruck als Parameter, der das Sortierkriterium beschreibt. <code>(p1, p2)</code> sind frei wählbare Variablennamen für die jeweils zwei zu vergleichenden Listenelemente der internen Sortierfunktion, ähnlich wie Sie dass vom BubbleSort Verfahren kennen. Entsprechend sind <code>p1</code> und <code>p2</code> im Beispiel vom Datentyp Person. Zur Laufzeit füllt <code>sort</code> diese Variablen selbstständig ab.</p>
<p>Die Zeichenfolge <code>-&gt;</code> stellt die Zuordnung der Variablen zur eigentlichen Vergleichsfunktion dar.</p>
<p>Danach folgt der eigentliche Vergleich: Wir wollen nach Familiennamen aufsteigend sortieren. Also greifen wir auf das Attribut <code>familyname</code> von <code>p1</code> zu. Dieses ist vom Datentyp String stellt die String-Funktion <code>compare</code> bereit. <code>compare</code> bekommt das <code>familyName</code>-Attribut von <code>p2</code> als Parameter. <code>String.compare</code> gibt -1 zurück, wenn <code>p1.familyname</code> im Alphabet vor <code>p2.familyName</code> kommt bzw. 1 im umgekehrten Fall. Der <code>sort(..)</code>-Befehl kümmert sich im Hintergrund um allfällige Tauschoperationen.</p>
<p>Da <code>sort(..)</code> keinen Rückgabetyp hat, wird <code>kundenverwaltung</code> in sich selbst sortiert. Auf Englisch heisst das &quot;in-place&quot;.</p>
<p><strong>Wiederholungsfragen</strong></p>
<ul>
<li><p>Wie lautet der Lambda-Ausdruck zum absteigenden Sortieren der Kundenverwaltung nach Nachnamen?</p></li>
<li><p>Wie lautet der Lambda-Ausdruck zum Sortieren einer <code>int</code>- oder <code>double</code>-Liste?</p></li>
<li><p>Wie sind Lambda-Ausdrücke prinzipiell aufgebaut?</p></li>
<li><p>Wie lautet der Lambda-Ausdruck zum absteigenden Sortieren der Kundenverwaltung nach Alter?</p></li>
</ul>
</section>
<section id="listen-mit-lambda-ausdrücken-filtern" class="level3">
<h3><span class="header-section-number">10.2.2</span> Listen mit Lambda-Ausdrücken filtern</h3>
<p>Häufig werden aus Listen bestimmte Teilmengen benötigt. Nun sollen wir beispielsweise aus der <code>kundenverwaltung</code> nur die Personen finden, die aus Appenzell stammen. Dazu können wir entweder klassisch alle Elemente der <code>kundenverwaltung</code> Liste einzeln aufrufen und das <code>city</code>-Attribut auf &quot;Appenzell&quot; vergleichen. Eleganter ist folgender Befehl (die Zeilenumbrüche dienen der Lesbarkeit):</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="bu">List</span>&lt;Person&gt; appenzeller = kundenverwaltung.<span class="fu">stream</span>().
	<span class="fu">filter</span>(p-&gt;p.<span class="fu">city</span>.<span class="fu">equals</span>(<span class="st">&quot;Appenzell&quot;</span>)).    <span class="co">//filter by city!</span>
	<span class="fu">collect</span>(Collectors.<span class="fu">toList</span>());</code></pre></div>
<p>Hier werden die Elemente der Liste <code>kundenverwaltung</code> mit der <code>stream()</code> -Funktion zunächst an die Funktion <code>filter(..)</code> übergeben.</p>
<p><code>filter(p-&gt;p.city.equals(&quot;Appenzell&quot;))</code> enthält wieder einen Lambda-Ausdruck. Zunächst wird die Variable <code>p</code> definiert. <code>p</code> ist vom Typ Person und hat ein Klassenattribut namens <code>city</code> vom Datentyp String.</p>
<p>Ein String <code>x</code> wird mittels <code>x.equals(String y)</code>-Funktion auf Gleichheit geprüft mit dem Parameter-String <code>y</code> geprüft. Dieser Ausdruck wird wahr, wenn alle Zeichen in <code>x</code> in der gleichen Reihenfolge in <code>y</code> vorkommen.</p>
<p>Der <code>filter(..)</code> Aufruf gibt also nur die Instanzen von Person weiter, die aus &quot;Appenzell&quot; stammen. Die Funktion <code>collect(Collectors.toList())</code> sammelt nun die gefilterten <code>person</code>-Objekte und hängt diese fein säuberlich in eine neue Liste. Diese speichern wir in der neuen Variable <code>List&lt;person&gt; appenzeller</code> ab.</p>
<p>Entsprechend kann beispielsweise eine Zahlenliste nach Zahlen grösser 10 und kleiner 20 wie gefiltert werden?</p>
<p>Probieren Sie es aus! Anbei - hinter den Kulissen verwenden die Lambda-Funktionen ebenfalls <em>Iteratoren</em>.</p>
<pre class="include"><code>skript2c_ueb01_lambda.md</code></pre>
</section>
</section>
<section id="die-map-datenstruktur" class="level2">
<h2><span class="header-section-number">10.3</span> Die <code>Map</code>-Datenstruktur</h2>
<p>Die <code>Map</code> Datenstruktur verwaltet Verbindungen von Werten (<em>values</em>) mit Schlüsseln (<em>key</em>). Primär dient diese Datenstruktur zum schnellen Auffinden von <code>values</code> anhand der <code>keys</code>, wobei <code>values</code> auch komplexe Objekte sein können. Vergleichbar ist die <code>map</code> mit Tabellen in relationalen Datenbanken. Hier entspricht der Primärschlüssel dem <code>key</code> einer <code>map</code>.</p>
<p>Die <code>map</code>-Struktur wird sehr oft eingesetzt. Ein klassisches Beispiel ist das Telefonbuch (oder die Kontakte auf Ihrem Smartphone). Auch im BigData Bereich werden derartige Key-Value Datenbanken häufig eingesetzt (z.B. Cassandra von Facebook).</p>
<p>Die <code>map</code>-Datenstruktur unterstützt üblicherweise 2 Operationen:</p>
<ul>
<li><code>put</code> --&gt; einfügen eines neuen Paares</li>
<li><code>get(key)</code> --&gt; suchen* nach dem Wert, der zu dem gegebenen Schlüssel gehört</li>
</ul>
<figure>
<img src="media/hashmap.png" alt="Hashmap" id="fig:fig_hashmap" /><figcaption>Hashmap</figcaption>
</figure>
<p>Dabei muss darauf geachtet werden, dass es nicht zu doppelten Einträgen (doppelte Schlüssel) kommt. Somit wird folgende Regel implementiert:</p>
<ul>
<li>Jeder Schlüssel ist immer nur mit einem Wert verbunden</li>
<li>Wenn ein Client ein Schlüssel-Wert-Paar einfügt, in der dieser Schlüssel (und ein damit verbundener Wert) bereits vorhanden ist, dann ersetzt der neue Wert den alten.</li>
</ul>
<p>In Java wird das Interface <code>Map</code> in vielen verschiedenen Klassen implementiert (siehe dazu Java API). Eine sehr oft verwendete Klasse ist der <code>HashMap</code>.</p>
<p>Code-Beispiel:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="bu">HashMap</span>&lt;<span class="bu">String</span>, <span class="bu">String</span>&gt; phoneBook = <span class="kw">new</span> <span class="bu">HashMap</span>&lt;<span class="bu">String</span>,<span class="bu">String</span>&gt;();

phoneBook.<span class="fu">put</span>(<span class="st">&quot;Lisa Jones&quot;</span>, <span class="st">&quot;(402) 4536 4674&quot;</span>);
phoneBook.<span class="fu">put</span>(<span class="st">&quot;Prince Harry&quot;</span>, <span class="st">&quot;(0044)79854 4512&quot;</span>);</code></pre></div>
<pre class="include"><code>skript2c_ueb02_map.md</code></pre>
</section>
<section id="wdh_javautils" class="level2">
<h2><span class="header-section-number">10.4</span> Wiederholungsfragen</h2>
<ul>
<li>Welche Gründe sprechen für den Einsatz vorgefertigter Datenstrukturen aus dem <code>java.util</code>-Package?</li>
<li>Was steht man unter <em>generischen</em> Datenstrukturen?</li>
<li>Wie wird die Sortierfunktion der <code>ArrayList</code>-Klasse parametrisiert?</li>
<li>Wie lautet der Aufruf zum Filtern einer ArrayList<Double>, wenn nur Elemente zwischen 10.0 und 20.0 ausgegeben werden sollen?</li>
<li>Welche Anforderungen gibt es an die <code>keys</code> bei der Verwendung der Map-Datenstruktur?</li>
</ul>
<p><a href="#TOC">Zurück zum Inhaltsverzeichnis</a></p>
</section>
</section>
<section id="dynamische-datenstrukturen-iv-json-und-xml" class="level1">
<h1><span class="header-section-number">11</span> Dynamische Datenstrukturen IV: JSON und XML</h1>
<section id="lernziele_xmljson" class="level2">
<h2><span class="header-section-number">11.1</span> Lernziele</h2>
<ul>
<li>beschreiben den Aufbau von baumartigen JSON- und XML-Datenstrukturen</li>
<li>nutzen Parser, um JSON- und XML-Strukturen zu lesen und in Objekte umzuwandeln</li>
<li>nutzen JSON- und XML-basierte Web-Services</li>
</ul>
</section>
<section id="die-datenstruktur-json" class="level2">
<h2><span class="header-section-number">11.2</span> Die Datenstruktur JSON</h2>
<p>Baumartige Datenstrukturen bestehen aus einem Wurzelelement mit beliebig vielen verschachtelten Unterelementen mit beliebig vielen Unterelementen und Attributen. Im Vergleich zu den normalisierten Tabellenstrukturen relationaler Datenbanken stellen Bäume gewissermassen die Daten <em>nicht-normalisierte</em> Ansicht über alle Tabellen dar.</p>
<figure>
<img src="media/xml-tree.png" alt="Schematischer Aufbau einer Baum-Struktur" id="fig:fig_tree" /><figcaption>Schematischer Aufbau einer Baum-Struktur</figcaption>
</figure>
<p>JSON (<em>Javascript Object Notation</em>) ist eine populäre Variante zur hierarchischen Abbildung von Informationen. Ursprünglich war JSON nur eine Erweiterung von Javascript. Seit 2005 bzw. 2006 setzen Yahoo, Google und viele andere JSON als Datenübertragungsformat für interaktive Webseiten (AJAX) und Web-Services ein.</p>
<pre><code>{&quot;data&quot;:[
	{&quot;person&quot;:{
			&quot;name&quot;:&quot;Melmak&quot;,
			&quot;vorname&quot;:&quot;Alf&quot;,
			&quot;plz&quot;: 1234,
		}
	}
	{&quot;person&quot;:{
			&quot;name&quot;:&quot;Nachhaus&quot;,
			&quot;vorname&quot;:&quot;ET&quot;,
			&quot;plz&quot;: 1248,
		}
	}
	{&quot;person&quot;:{
			&quot;name&quot;:&quot;Quack&quot;,
			&quot;vorname&quot;:&quot;Alfred J.&quot;,
			&quot;plz&quot;: 1111,
		}
	}
  ],
}</code></pre>
<p>Das Beispiel illustriert einen Array (oder Liste) von JSON-Objekten mit den <strong>&quot;Schlüsseln&quot;</strong> <em>name</em>, <em>vorname</em> und <em>plz</em>. JSON-Objekte bestehen immer aus ein oder mehreren Schlüssel-Wert Paaren, ähnlich wie Java Maps. <strong>Werte</strong> können <strong>atomar</strong> sein, hier z.B. Strings. Werte können weitere JSON-Objekte oder <em>Listen</em> enthalten. Listen werden in JSON mit <strong>[]</strong> umschlossen, JSON-Objekte mit <strong>{}</strong>. Schlüssel und Wert sind mit <strong>&quot;:&quot;</strong> getrennt.</p>
<p>Listenobjekte haben oft ein zusätzliches <em>ID</em>-Attribut, ähnlich dem Primärschlüssel einer Tabelle in mySQL.</p>
<section id="json-mit-java-parsen" class="level3">
<h3><span class="header-section-number">11.2.1</span> JSON mit Java parsen</h3>
<p>Es gibt eine Vielzahl von JSON-Parsern für Java. Wir nutzen exemplarisch die auf <a href="http://www.json.org">www.json.org</a> vorgeschlagene JSON-Java Bibliothek für Java SE 8. Laden Sie das JAR unter folgendem Link und binden Sie diese in Ihr Eclipse-Projekt ein:</p>
<p><a href="https://search.maven.org/remotecontent?filepath=org/json/json/20151123/json-20151123.jar" class="uri">https://search.maven.org/remotecontent?filepath=org/json/json/20151123/json-20151123.jar</a></p>
<p>Wichtigen Klassen sind <code>JSONObject</code> und <code>JSONArray</code>. Sie werden mit der <code>import</code> Anweisung einge­bunden:</p>
<pre><code>import org.json.JSONObject; 
import org.json.JSONArray;</code></pre>
<p>Zunächst wird die gesamte JSON-Zeichenkette als Parameter dem JSONObject Konstruktor übergeben. Die Variable <code>jsonString</code> wurde vorher aus einem beliebigen Datenstrom (<code>BufferedReader, StreamReader</code> etc.) eingelesen.</p>
<pre><code>JSONObject obj = new JSONObject(jsonString);</code></pre>
<p>Die vorerst wichtigsten Methoden der <code>JSONObject Klasse</code> sind:</p>
<ul>
<li><p><code>JSONArray get(String key):</code> liefert alle Child-Elemente mit Namen <em>key</em> als JSONArray, wenn man es als solches <em>castet</em>.</p></li>
<li><p><code>double getDouble(String key):</code> liefert den Attributwert für key als <code>double</code>; entsprechende Methoden sind auch für <code>int</code> und weitere Datentypen implementiert</p></li>
<li><p><code>JSONObject getJSONObject(String key)</code>: liefert ein Child-Element für key als <code>JSONObject</code></p></li>
<li><p><code>Set&lt;String&gt; keys()</code>: liefert die Schlüssel aller enthaltenen Elemente zurück.</p></li>
</ul>
<p>Über die in JSONArrays enthaltenen JSONObjects kann man elegant iterieren. Das Gleiche gilt natürlich auch für key-Sets:</p>
<pre><code>obj.keys().forEachRemaining(key -&gt; {
	System.out.println(key);
	System.out.println(obj.get(key).toString());
	System.out.println(&quot;***********************************&quot;);
	}
);</code></pre>
<p>Wenn JSON gleichartig aufgebaut Daten verwendet, können Sie die Listen-Objekte in eine entsprechende Java-Klassen einlesen und beispielsweise als <code>ArrayList</code> ablegen. Dies spart für die weitere Verarbeitung viel Zeit, da JSON nicht immer und immer wieder geparst werden muss.</p>
</section>
<section id="json-web-services-nutzen" class="level3">
<h3><span class="header-section-number">11.2.2</span> JSON – Web-Services nutzen</h3>
<p>Wie bereits erwähnt, sind JSON-Datenstrukturen sehr häufig als Datenstruktur von Web-Services anzutreffen. Ein Web-Service ist ein http-Server, der auf einer bestimmte URL auf parametrisierte Anfragen wartet und diese (meist mittels Datenbanken-Zugriff) mit wohl definierten JSON- oder XML-Datenstrukturen beantwortet. Der Client sendet Parameter für den Web-Service werden entweder via GET in der URL oder als POST Request. Ein ausführliches Beispiel dazu finden Sie in der nachfolgenden Übung.</p>
<pre class="include"><code>skript3_ueb2_json_ws.md</code></pre>
</section>
</section>
<section id="einführung-in-xml" class="level2">
<h2><span class="header-section-number">11.3</span> Einführung in XML</h2>
<p>XML (eXtensible Markup Language) ist ebenfalls eine Baumstruktur bzw. hierarchische Datenstruktur. XML gibt es schon seit 1998 und war ursprünglich als Dokumenten-Format konzipiert. Microsoft Word Dokumente werden beispielsweise als XML-Dokumente gespeichert. XML wird häufig zur Datenübertragung bei Web-Services verwendet.</p>
<section id="aufbau" class="level3">
<h3><span class="header-section-number">11.3.1</span> Aufbau</h3>
<p>Wie HTML besteht XML aus einem Wurzelelement mit beliebig vielen verschachtelten Unterelementen mit beliebig vielen Unterelementen und Attributen. Ein Element wird in der XML-Welt Node genannt. Eine Node besteht auch hier aus einem Start-TAG und einem End-TAG. Dazwischen befindet sich der Node-Inhalt.</p>
<p>Im Gegensatz zu HTML sind die Namen der Nodes nicht von einem Consortium global festgeschrieben, sondern werden für den jeweiligen Anwendungsfall definiert. Wollen wir beispielsweise unsere Liste der Klasse Person (siehe Abb. <span class="citation" data-cites="fig:fig_tree">@fig:fig_tree</span>) als XML abspeichern, könnte das Dokument bzw. als Baumstruktur so aussehen:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;data&gt;
	&lt;person&gt;
		&lt;name&gt;Quack&lt;/name&gt;
		&lt;vorname&gt;Alfred Jodokus&lt;/vorname&gt;
		&lt;geburtstag&gt;11.11.2011&lt;/geburtstag&gt;
		&lt;strasse&gt;Narrenstrasse 11&lt;/strasse&gt;
		&lt;ort&gt;Jeckendorf&lt;/ort&gt;
		&lt;plz&gt;1111&lt;/plz&gt;
	&lt;/person&gt;
	&lt;person&gt;...&lt;/person&gt;
	&lt;person&gt;...&lt;/person&gt;
&lt;/data&gt;</code></pre>
<p>Das <em>data</em>-Node enthält beliebig viele <em>person</em>-Nodes. Diese wiederum enthalten die entsprechenden Klassenattribute und Werte (als Strings). Damit wird ein plattform­unabhängiges Austauschformat für Datenobjekte erreicht. Entsprechend können Daten unter anderem via XML zwischen C++, Java, PHP und .NET ausgetauscht werden. Und deshalb ist XML beispielsweise für Web-Services so interessant geworden.</p>
</section>
<section id="xml-parser" class="level3">
<h3><span class="header-section-number">11.3.2</span> XML Parser</h3>
<p>Zur Verarbeitung von XML oder JSON sind entsprechende &quot;Parser&quot; notwendig. Parser kommt aus dem Englischen und steht für Analysieren. Bei XML gibt es zwei Varianten:</p>
<table style="width:99%;">
<colgroup>
<col style="width: 62%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong><em>Simple API for XML (SAX)</em></strong></th>
<th style="text-align: left;"><strong><em>Document Object Model (DOM)</em></strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Sehr schnell, da es Ereignis-gesteuert wird. D.h. die Struktur muss zum voraus bekannt sein, um auf die entsprechenden Elemente /Tags reagieren zu können.</td>
<td style="text-align: left;">Eher langsam, da das gesamte XML als DOM Baum abgebildet wird.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Keine Navigation in der XML-Struktur möglich.</td>
<td style="text-align: left;">Es kann über die Elemente navigiert werden mit <code>getParent()</code>, <code>getChild()</code>, etc.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Sehr handlich, wenn es sich um grössere XML-Daten handelt und nur ein bestimmter Ausschnitt (also ein Element) benötigt wird.</td>
<td style="text-align: left;">Handlich für kleinere Daten, bzw. wenn das Parsen nicht zu viel Zeit und Speicher benötigt.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Z.Bsp. In einer Nachricht (news) möchte ich nur die Schlagzeile in meiner Applikation verwenden (ohne Texte, Photos, etc.).</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">XML wird nicht auf gültige Struktur geprüft.</td>
<td style="text-align: left;">XML wird auf gültige Struktur geprüft.</td>
</tr>
</tbody>
</table>
</section>
<section id="aufgabe-aus-xml-ein-dom-erstellen" class="level3">
<h3><span class="header-section-number">11.3.3</span> Aufgabe: Aus XML ein DOM erstellen</h3>
<p>Wir wollen den DOM XML-Parser zunächst an einem einfachen Beispiel umsetzen:</p>
<pre><code>&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt;
&lt;CATALOG&gt;
	&lt;CD&gt;
		&lt;TITLE&gt;Greatest Hits&lt;/TITLE&gt;
		&lt;ARTIST&gt;Elvis&lt;/ARTIST&gt;
		&lt;COUNTRY&gt;USA&lt;/COUNTRY&gt;
		&lt;YEAR&gt;1977&lt;/YEAR&gt;
	&lt;/CD&gt;
	&lt;CD&gt;
		&lt;TITLE&gt;Eros&lt;/TITLE&gt;
		&lt;ARTIST&gt;ErosRamazzotti&lt;/ARTIST&gt;
		&lt;COUNTRY&gt;EU&lt;/COUNTRY&gt;
		&lt;YEAR&gt;1997&lt;/YEAR&gt;
	&lt;/CD&gt;
&lt;/CATALOG&gt;</code></pre>
<p>Jedes Element im XML entspricht einem Knoten ( = <em>Node</em>). Somit besteht z.Bsp. der Knoten <em>CD</em> aus den Sub-Knoten <em>TITLE</em>, <em>ARTIST</em>, etc. Dies entspricht einer Liste von Knoten (= <code>NodeList</code>).</p>
<p>Um XML-Inhalte mit Java zu lesen, müssen einige Bibliotheken eingebunden werden:</p>
<pre><code>import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Node;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;</code></pre>
<p>Die XML-Datei wird in der Klasse <code>Document</code> als DOM abgebildet. Dabei parst der <code>DocumentBuilder</code> das XML und wandelt es in ein <code>Document</code> (eine Java-interne Datenstruktur) um:</p>
<pre><code>\* parses XML File filename and returns a NodeList of CD Nodes *\

public NodeList generateNodeList(String filename){
	DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
	DocumentBuilder db;
	Document doc = null;
	try {
		db = dbf.newDocumentBuilder();
		doc = db.parse(new File(filename)); //parse XML
	} 
	catch (SAXException e) {
	e.printStackTrace();
	} 
	catch (IOException e) {
		e.printStackTrace();
	} 
	catch (ParserConfigurationException e) {
		e.printStackTrace();
	}

	//puts all text nodes into full-depth underneath this node:
	//doc.getDocumentElement().normalize(); (old version)
	doc.normalize();
	//get list of CDs:
	NodeList cdElements = doc.getElementsByTagName(&quot;CD&quot;);
	return cdElements;
}
</code></pre>
<p>Eine Knotenliste wird an einem bestimmten Tag-Element definiert. Somit hat diese <code>NodeList</code> alle Knoten mit &quot;CD&quot; und somit auch alle Kinder (children).</p>
<p>Die Klasse <code>NodeList</code> implementiert das Collection-Interfase nicht. Stattdessen wird mit der NodeList-Methode <code>item(int i)</code> per Index auf die Elemente zugegriffen. Entsprech­end muss man in einer for-Schleife über diese Liste iterieren, um die weiteren Sub-Knoten auszulesen bzw. wiederum einer Liste zuweisen.</p>
<p>Die Klasse Node bietet über die Funktion <code>String getTextContent()</code> eine einfache Variante, den Inhalt einer Node x (und aller darin enthaltenen Nodes) anzuschauen. Dabei werden die Namen der Kinder-Elemente verworfen und nur deren Text-Inhalte angezeigt:</p>
<pre><code>NodeList list = generateNodeList(&quot;cd_catalog.xml&quot;);
for (int i=0; i &lt; list.getLength(); i++){
  System.out.println(list.intem(i).getTextContent);
}</code></pre>
<p>Will man stattdessen auf den Inhalt bestimmter Kinder-Elemente zugreifen, geht man folgendermassen vor:</p>
<pre><code>for (int i=0; i &lt; list.getLength(); i++){
	Node node = list.item(i);
	if (node.getNodeType()==Node.ELEMENT_NODE){
			Element e = (Element)node;
			NodeList titleElements = e.getElementsByTagName(&quot;TITLE&quot;).
			item(0).getChildNodes();
			NodeList artistElements = e.getElementsByTagName(&quot;ARTIST&quot;).
			item(0).getChildNodes();

			System.out.println(&quot;Title: &quot;+titleElements.item(0).getTextContent());
			System.out.println(&quot;, Artist: &quot;+artistElements.item(0).getTextContent());
			System.out.println();
	}
}</code></pre>
<p>Durch das Casting der Nodes von <code>list</code> auf das org.w3c.dom-Interface <code>Element e</code> kann man wiederum mit der Methode <code>getElementsbyName(String name)</code> die Child-Nodes parsen. Dies ergibt wiederum eine NodeList, von der wir in diesem Fall wissen, dass wir nur das erste Element benötigen.</p>
<p><strong>Fazit:</strong> Man muss als Entwickler den Aufbau der zu lesenden XML sehr genau kennen. Dann allerdings lassen sich sehr einfach Java-Klassen einlesen oder speichern.</p>
<section id="aufgabe" class="level4">
<h4><span class="header-section-number">11.3.3.1</span> Aufgabe:</h4>
<p>Parsen Sie das XML-File <code>cd_catalog.xml</code> wie im obigen Beispiel in ein DOM ab und geben Sie für jede CD den Titel, den Künstler und das Jahr aus.</p>
</section>
</section>
<section id="xml-web-services-nutzen" class="level3">
<h3><span class="header-section-number">11.3.4</span> XML – Web-Services nutzen</h3>
<p>Wie bereits erwähnt, sind XML Datenstrukturen sehr häufig als Datenstruktur von Web-Services anzutreffen. Ein Web-Service ist ein http-Server, der auf einer bestimmte URL auf parametrisierte Anfragen wartet und diese (meist mittels Datenbanken-Zugriff) mit wohl definierten XML- oder JSON-Datenstrukturen beantwortet. Der Client sendet Parameter für den Web-Service werden entweder via GET in der URL oder als POST Request.</p>
<p>Holen wir uns von einem Dictionaire-Web-Service die Definitionen für einen bestimmten Begriff:</p>
<p><a href="http://services.aonaware.com/DictService/DictService.asmx/Define?word=xml" class="uri">http://services.aonaware.com/DictService/DictService.asmx/Define?word=xml</a></p>
<p>Kopieren Sie zunächst diesen Link in Ihren Webbrowser und interpretieren Sie die Antwort des Servers.</p>
<p>Wie können solche Web-Services aus einem Programm benutzt werden? Um den Service aus Java aufzurufen, benötigen Sie eine URL-Verbindung. Unten ­stehender Code zeigt Ihnen eine Verbindung sowie eine einfache Ausgabe als String:</p>
<pre><code>String searchWord = &quot;xml&quot;;
//call web-service and get input stream result:
URL url = new URL(&quot;http://services.aonaware.com/&quot; +
		&quot;DictService/DictService.asmx/Define?word=&quot;+ searchWord);
URLConnection yc = url.openConnection();

//test and show result as String:
BufferedReader in = newBufferedReader(newInputStreamReader(yc.getInputStream()));
String inputLine;
while ((inputLine = in.readLine()) != null) 
	System.out.println(inputLine);
	
in.close();</code></pre>
<p>Welche Elemente erhalten Sie vom Service?</p>
<p>Wir wollen nur das Element &quot;WordDefinition&quot; dem Benutzer anzeigen. Wie müssen Sie über die XML-Struktur iterieren, damit Sie den Wert erhalten?</p>
</section>
</section>
<section id="generieren-und-schreiben-von-xml-und-json" class="level2">
<h2><span class="header-section-number">11.4</span> Generieren und Schreiben von XML und JSON</h2>
<p>Die behandelten Java-Bibliotheken stellen ebenfalls Methoden zum Erstellen von XML / JSON Datenstrukturen zur Verfügung. Diese können in diesem Kurs nicht mehr behandelt werden, sind jedoch mit etwas Recherche und Übung leicht nachzuvollziehen.</p>
</section>
<section id="wdh_xml_json" class="level2">
<h2><span class="header-section-number">11.5</span> Wiederholungsfragen</h2>
<ul>
<li>XML und JSON sind baumartige Datenstrukturen. Was bedeutet das?</li>
<li>Was ist der Unterschied zwischen XML und JSON?</li>
<li>Wie können XML- und JSON basierte Web-Services mit Java benutzt werden?</li>
</ul>
<p><a href="#TOC">Zurück zum Inhaltsverzeichnis</a></p>
</section>
</section>
<section id="rekursion-und-backtracking" class="level1">
<h1><span class="header-section-number">12</span> Rekursion und Backtracking</h1>
<section id="lernziele_rekursion" class="level2">
<h2><span class="header-section-number">12.1</span> Lernziele</h2>
<ul>
<li><p>verstehen das Prinzip von Rekursion und wenden es Beispielen an</p></li>
<li><p>verstehen das Prinzip des Backtracking und zeigen es an einem Beispiel auf</p></li>
</ul>
</section>
<section id="rekursion" class="level2">
<h2><span class="header-section-number">12.2</span> Rekursion</h2>
<p>Die Rekursion ist ein zentrales Konzept in der Computerwissenschaft, um komplexere Probleme in einfache, überschaubare Problemgebiete zu unterteilen. Auch hier gilt das alte Sprichwort: <em>Teile und Herrsche</em>. Eine einfache Definition von Rekursion ist:</p>
<p><em>Ein Problem wird mit einer Funktion in ein Teil-Problem zerlegt, das wiederum mit der gleichen Funktion weiter zerlegt wird, bis der Rest des Problems gelöst ist.</em></p>
<section id="rekursion-in-einer-datenstruktur" class="level3">
<h3><span class="header-section-number">12.2.1</span> Rekursion in einer Datenstruktur</h3>
<p>Wir haben die Rekursion bereits bei Datenstrukturen wie verkettete Listen und Stapel kennengelernt:</p>
<pre><code>public class Node{
	//these are private
	private Object item;
	privateNodenext;
	//constructor
	public Node (Object value){
		next = null;
		item = value;
	}
...
}</code></pre>
<p>Die Klasse <code>Node</code> besitzt als Eigenschaft wiederum sich selbst. Sie verwendet rekursiv die eigene Klasse, um auf das nächste Element zu verweisen.</p>
</section>
<section id="rekursive-algorithmen" class="level3">
<h3><span class="header-section-number">12.2.2</span> Rekursive Algorithmen</h3>
<p>Unter rekursiven Algorithmen versteht man Funktionen, in denen Aufrufe zu sich selbst vorkommen. Entsprechend muss eine <em>Abbruchbedingung</em> definiert sein, damit es nicht zu unendlichen Aufrufen der Methode kommt.</p>
<p><strong>Beispiel: Fakultätsberechnung </strong></p>
<p>Es gibt unzählige Beispiele für Probleme, die man am einfachsten mittels einer Rekursion löst. Ein einfaches mathematisches Problem ist die Berechnung der Fakultät (<code>fak(n)</code> = Produkt der Zahlen von 1 bis <code>n</code>) , hier in Pseudo-Code:</p>
<pre><code>int fak(n){
	if (n==1)
		return 1;
	return n * fak(n-1);
}</code></pre>
<p>Die Funktion gibt das Produkt von <code>n</code> multipliziert mit dem Rückgabewert von <code>fak(n-1)</code> aus. Tatsächlich wird für jedem rekursiven Aufruf ein neuer Abschnitt im Arbeitsspeicher (auf dem <em>Stack</em>) angelegt. Darin wird die Rücksprung-Adresse und die lokalen Variablen der aufgerufenen Funktion abgelegt. Beim Erreichen der Abbruchbedingung(hier <code>n==1</code>) und damit dem Ende des Unterprogramm-Aufrufs werden diese Speicherbereiche vom Stack wieder von oben nach unten freigegeben.</p>
<p>Detailiertere Informationen über <em>Stack</em>- und <em>Heap</em>-Speichermanagement finden Sie unter <a href="http://www.fh-wedel.de/~si/seminare/ws02/Ausarbeitung/2.jvm/javavm2.htm" class="uri">http://www.fh-wedel.de/~si/seminare/ws02/Ausarbeitung/2.jvm/javavm2.htm</a>.</p>
<figure>
<img src="media/rekursion_stack.png" alt="Auf- und Abbau des Programmstacks" id="fig:fig_progstack" /><figcaption>Auf- und Abbau des Programmstacks</figcaption>
</figure>
<p><strong>Beispiel: Fibonacci-Reihe berechnen</strong></p>
<p>Die Fibonacci-Reihe (1,1,2,3,5,8,…) kann mittels Rekursion berechnet werden:</p>
<figure>
<img src="media/Fibonacci_sequence_-_optional_starting_with_zero.jpg" alt="Fibonacci-Folge, Quelle: https://de.wikipedia.org/wiki/Fibonacci-Folge" id="fig:fig_fibo" /><figcaption>Fibonacci-Folge, Quelle: <a href="https://de.wikipedia.org/wiki/Fibonacci-Folge"><em>https://de.wikipedia.org/wiki/Fibonacci-Folge</em></a></figcaption>
</figure>
<pre><code>public int calculate(int number) {
	if((number == 0) || (number == 1)){
		return number;
	}
	else {
		return calculate(number -1) + calculate(number-2);
	}
}</code></pre>
<p>Die Methode <code>calculate</code> ist ein Beispiel einer <em>Mehrfach-Rekursion</em>, da die Methode gleich mehrmals (hier zweimal) aufgerufen wird.</p>
<p><strong>Beispiel: MergeSort</strong></p>
<p>Das <em>MergeSort</em>-Verfahren zum Sortieren von Listen arbeitet ebenfalls mit einer Mehrfach-Rekursion. Er besteht aus den zwei Funktionen <em>Mischen</em> und <em>Zusammenführen</em>. Details zur Implementierung finden Sie unter <a href="https://de.wikipedia.org/wiki/Mergesort" class="uri">https://de.wikipedia.org/wiki/Mergesort</a> oder <a href="https://tinohempel.de/info/info/ti/mergesort.htm" class="uri">https://tinohempel.de/info/info/ti/mergesort.htm</a>.</p>
<p>Die Laufzeitkomplexität von von <em>MergeSort</em> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot log(n))</annotation></semantics></math>) ist wesentlich günstiger als die von <em>BubbleSort</em> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math>). Dafür benötigt <em>MergeSort</em> wesentlich mehr Arbeitsspeicher, und ist eher für Listen als für Arrays geeignet.</p>
<p><strong>Beispiel: Rekursives Durchlaufen von Baumstrukturen</strong></p>
<p>Rekursion eignen sich auch zum Durchsuchen von Baum-Strukturen, um die einzelnen Knoten zu durchlaufen (traversieren). Wir können mit der Funktion <code>visitRecursively</code> JSON- oder XML-Strukturen durchlaufen und dabei alle Child-Elemente (Kinder) in der Struktur rekursiv aufrufen:</p>
<pre><code>public void visitRecursively(Node node) {
	// get child nodes:
	NodeList list = node.getChildNodes();
	for (int i=0; i&amp;lt;list.getLength(); i++) {
		// get child node:
		Node childNode = list.item(i);
		System.out.println(&quot;Found Node: &quot; + childNode.getNodeName()
			+ &quot; - with value: &quot; + childNode.getNodeValue());
		// call next children with recursion:
		visitRecursively(childNode);
	}
}</code></pre>
<p>Analog dazu kann man natürlich auch Dateisysteme mit rekursiven Funktionen durchlaufen.</p>
</section>
</section>
<section id="rekursion-vs-iteration" class="level2">
<h2><span class="header-section-number">12.3</span> Rekursion vs Iteration</h2>
<p>Jede Rekursion kann in eine Iteration umgewandelt werden. Die Rekursion ist meistens die elegantere Lösung. Jedoch sind rekursive Funktionen aufgrund des oben beschriebenen Stack-Speicherhandlings oft weniger performant. Ja nach geforderter Performance macht es also mehr Sinn, ein Problem iterativ (also mit einer Schleife) oder rekursiv zu lösen. Gewisse Programmiersprachen verbieten explizit die Iteration und bevorzugen die Rekursion (z.Bsp. LISP oder Prolog).</p>
<p>Beispiel: Eine Funktion soll die Zahlen von <code>n1</code> bis <code>n2</code> ausgeben, wobei <code>n1 &lt;= n2</code> sein soll.</p>
<p>Als Iteration würden wir es so programmieren:</p>
<pre><code>public static void printSeries(int n1, int n2){
	for (int i = n1; i &lt; n2; i++){
		System.out.print(i + &quot;,&quot;);
	}
	System.out.print(n2);
}</code></pre>
<p>Wir können diese Iteration auch als Rekursion programmieren:</p>
<pre><code>public static void printSeries(int n1, int n2){
	//stop recursion:
	if (n1 == n2){
		System.out.print(n2);
	} 
	else {
		System.out.print(n1 + &quot;,&quot;);
		printSeries(n1 + 1, n2); //recursive call
	}
}</code></pre>
<pre class="include"><code>skript4_ueb01_rekursion.md

skript4_ueb02_farn.md

skript4_ueb03_Mandelbrot.md</code></pre>
</section>
<section id="backtracking" class="level2">
<h2><span class="header-section-number">12.4</span> Backtracking</h2>
<p>Backtracking ist eine Form von Rekursion, bei der verschiedene Lösungswege für ein Problem durchsucht werden. Wenn man beim Suchen der Lösung merkt, dass dies der falsche Weg ist, wird der Weg bis zur letzten Entscheidung zurückgegangen und es wird nach einer neuen Lösung gesucht. Am einfachsten stellt man sich das Suchen nach einer Lösung in Form eines Baumes vor:</p>
<figure>
<img src="media/tree.gif" alt="Baum-Struktur" id="fig:fig_tree2" /><figcaption>Baum-Struktur</figcaption>
</figure>
<ol type="1">
<li>Man beginnt bei <em>Root</em> und hat A oder B zur Auswahl. Man wählt A.<br />
</li>
<li>Bei A haben wir C oder D zur Auswahl. Man wählt C.<br />
</li>
<li><p>C ist schlecht. Gehen wir zurück zu A.</p></li>
<li>Bei A haben wir C schon probiert. Versuchen wir D.<br />
</li>
<li><p>D ist schlecht. Gehen wir zurück zu A.</p></li>
<li>Bei A haben wir keine weitere Lösungswege. Gehen wir zurück zu <em>Root</em>.<br />
</li>
<li>Bei <em>Root</em> haben wir A schon probiert. Versuchen wir B.<br />
</li>
<li>Bei B haben E und F zur Auswahl. Versuchen wir E.<br />
</li>
<li><p>E ist gut. Wir haben einen Weg gefunden.</p></li>
</ol>
<p>Der Baum ist eine abstrakte Struktur, um Lösungswege zu veranschaulichen. Bei den meisten Problemen haben wir keine Baumstruktur, sondern müssen mit anderen Datenstrukturen (z.Bsp. Arrays) arbeiten. In Pseudocode sieht ein Backtracking-Algorithmus wie folgt aus:</p>
<pre><code>boolean solve(Node n) {
	if n is a leafnode {
		if the leaf is a goal node return true
	else 
		return false
	}
	else {
		foreach child c of n {
			if solve(c) succeeds, return true
		}
		return false
	}
}</code></pre>
<p>Wichtig ist, dass die Backtracking-Funktion als <em>boolean</em> umgesetzt wird. Somit wissen wir, wenn ein bestimmter Knoten (<em>Node</em>) <em>true</em> ist, dass wir einen gültigen Lösungsweg haben.</p>
<p>Der Algorithmus besteht aus 2 Teilen:</p>
<p>Am Ende eines Lösungsweges prüfen wir den Erfolg:</p>
<pre><code>if the leaf is a goal node:
	return true
else: 
	return false</code></pre>
<p>Und der rekursive Teil, wo wir solange in Unter-Wegen suchen (mit Rekursion) bis eine erfolgreiche Lösung gefunden wurde oder gar keine:</p>
<pre><code>foreach child c of n {
	if solve(c) succeeds, return true
}
return false</code></pre>
<p>Quelle: <a href="http://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html"><em>http://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html</em></a> (Stand Sept. 2015)</p>
<a href="#TOC">Zurück zum Inhaltsverzeichnis</a>
</article>
</section>
</section>
</body>
</html>
